---
title: JVM整理
categories: Java
tags: JVM
abbrlink: 3895
date: 2022-11-19 16:11:28
---
虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。
<!-- more -->
### 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？

Java [虚拟机](https://so.csdn.net/so/search?q=虚拟机&spm=1001.2101.3001.7020)是一个可以执行 Java 字节码的虚拟机进程。

不同的平台都有相应实现的JVM，因为字节码文件是JVM上运行的，和平台无关。

### Java 内存区域和 JMM 有何区别？

这是一个比较常见的问题，很多初学者非常容易搞混。 **Java 内存区域和内存模型是完全不一样的两个东西** ：

- JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。
- Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。

### Java内存区域

在jdk1.8之前

![img](https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211141645727.png)

在JDK1.8之后

![img](https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211141645321.png)

### 解释 JVM 堆空间及 GC？

分类两部分：

* 年轻代：
  * Eden：新创建的对象会存放到这
  * S0：Eden满之后，会触发一次MinorGC，会将存活的对象放到这
  * S1：当S0存满时，会触发一次MinorGC，将存活的对象移动到到这，此时发生一次位置交换，S1在一段时间内处于空
* 老年代：
  * 经过多次的Minor GC后，仍然存活的对象会移动到这

### 说一下 JVM 的主要组成部分及其作用？

* 类加载器：加载类文件到内存。Class loader只管加载，只要符合文件结构就加载，至于能否运行，它不负责，那是有Exectution Engine 负责的。

* 执行引擎：也叫解释器，负责解释命令，交由操作系统执行。

* 本地库接口：本地接口的作用是融合不同的语言为java所用

* 运行时的数据区：

  * 堆：堆是java对象的存储区域，任何用new字段分配的java对象实例和数组，都被分配在堆上，java堆可用-Xms和-Xmx进行内存控制，jdk1.7以后，运行时常量池从方法区移到了堆上。
  * 方法区（1.7：永久代，1.8：元空间）： 用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。

  * 虚拟机栈：虚拟机栈中执行每个方法的时候，都会创建一个栈桢用于存储局部变量表，操作数栈，动态链接，方法出口等信息。
  * 本地方法栈：与虚拟机发挥的作用相似，相比于虚拟机栈为Java方法服务，本地方法栈为虚拟机使用的Native方法服务，执行每个本地方法的时候，都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。
  * 程序计数器：指示Java虚拟机下一条需要执行的字节码指令。	

### 深拷贝和浅拷贝？

* 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。

* 深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

### 浅拷贝和赋值的区别？

- 当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。
- 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。

### 说一下堆栈的区别？

* 栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。

* 堆内存存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。

### 什么是直接内存？

直接内存是Java堆外的、直接向系统申请的内存区间。

常用于大文件读写，Java的NIO库允许Java程序使用直接内存，用于数据缓冲区。

缺点：分配回收成本高，不受JVM内存回收管理。

大小：可以通过MaxDirectMemorySize设置，如果不指定，默认与堆的最大值一Xmx参数值一致。

### 对象的创建过程？

1. 检查类是否已经被加载
2. 为对象分配内存空间
   * 指针碰撞：这种分配方式建立在内存是绝对规整的前提下，将堆内存区域分为两个部分，一部分是分配过内存的地方，一部分是未分配过内存的地方，使用指针指向的方式，将两块区域分别开来。分配内存时。
   * 空闲链表：这个方式解决内存堆空间不连续的情况，已使用和未使用的空间在一起相互交融。在分配内存的时候，找到一块足够大的内存交给对象，但是这种方式会造成内存空间的碎片化。
3. 为对象字段设置零值
4. 设置对象头
5. 执行构造方法

### 并发情况下对象安全性

* CAS 虚拟机采用CAS配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。
* 本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存。通过-XX:+/- UseTLAB参数来设定虚拟机是否使用TLAB(JVM会默认开启-XX:+UseTLAB)，-XX:TLABSize 指定TLAB大小。

### 对象的访问定位

Java 类型分为基础数据类型（int 等）和引用类型（Reference），虽然两者都是数值，但却有本质的区别：基础数据类型本身就代表数据，而引用本身只是一个地址，并不代表对象数据。那么，虚拟机是如何通过引用定位到实际的对象数据呢？具体访问定位方式取决于虚拟机实现，目前有 2 种主流方式：

- **1、直接指针访问：** 引用内部持有一个指向对象数据的直接指针，通过该指针就可以直接访问到对象数据。采用这种方式的话，就需要在对象数据中额外使用一个指针来指向对象类型数据；
- **2、句柄访问：** 引用内部持有一个句柄，而句柄内部持有指向对象数据和类型数据的指针（句柄位于 Java 堆中句柄池）。使用这种方式的话，就不需要在对象数据中记录对象类型数据的指针。

使用句柄的优点是当对象在垃圾收集过程中移动存储区域时，虚拟机只需要改变句柄中的指针，而引用保持稳定。而使用直接指针的优点是只需要一次指针跳转就可以访问对象数据，访问速度相对更快。以 Sun HotSpot 虚拟机而言，采用的是直接指针方式，而 Android ART 虚拟机采用的是句柄方式。

[handle.h](https://link.juejin.cn?target=http%3A%2F%2Fandroidxref.com%2F9.0.0_r3%2Fxref%2Fart%2Fruntime%2Fhandle.h%23reference_)

```cpp
// Android ART 虚拟机源码体现：
// Handles are memory locations that contain GC roots. As the mirror::Object*s within a handle are
// GC visible then the GC may move the references within them, something that couldn't be done with
// a wrap pointer. Handles are generally allocated within HandleScopes. Handle is a super-class
// of MutableHandle and doesn't support assignment operations.
template<class T>
class Handle : public ValueObject {
	...
}
复制代码
```

**直接指针访问：**

![img](https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211151023755.webp)

**句柄访问：**

![img](https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211151023791.webp)




### 怎样通过 Java 程序来判断 JVM 是 32 位 还是 64位？

获取属性：System.getProperty("sun.arch.data.model")；

### 32 位 JVM 和 64 位 JVM 的最大堆内存分别是多少？

* 32位JVM的寻址空间只有2^32（4G），也就是说你的进程最大只能使用4G内存。并且由于还存在其他的一些限制，比如说swap空间、内核空间占用、内存碎片等等，实际上jvm可利用的内存要远小于4G。

  

* | OS       | Max Heap |
  | -------- | -------- |
  | Linux    | 2-3GB    |
  | AIX      | 3.25GB   |
  | Windows  | 1.5GB    |
  | Solaris  | 2~4GB    |
  | Mac OS X | 3.8GB    |

* 64位JVM，寻址空间最大是2^64，几乎就是无限大了。

### JRE、JDK、JVM 及 JIT 之间有什么不同？

* JVM：Java虚拟机，是JRE的一部分。它是整个java实现跨平台的最核心的部分，负责解释执行字节码文件，是可运行java字节码文件的虚拟计算机。所有平台的上的JVM向编译器提供相同的接口，而编译器只需要面向虚拟机，生成虚拟机能识别的代码，然后由虚拟机来解释执行。
* JRE：JRE（Java Runtime Environment，Java运行环境），包含JVM标准实现及Java核心类库。 JRE中包含了Java virtual machine（JVM），runtime class libraries和Java application launcher，这些是运行Java程序的必要组件
* JDK：Java Development ToolKit(Java开发工具包)。JDK是整个JAVA的核心，包括了Java运行环境（JRE），Java工具（javac/java/jdb等）和Java基础的类库（即Java API ）。
* JIT：当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”编译成本地机器相关的机器码，并进行优化，然后再把编译后的机器码缓存起来，以备下次使用。

### Java内存溢出异常，什么情况下会发生栈内存溢出？

在年轻代中经过GC后还存活的对象会被复制到老年代中。当老年代空间不足时，JVM会对老年代进行完全的垃圾回收（Full GC）。如果GC后，还是无法存放从Survivor区复制过来的对象，就会出现OOM（Out of Memory）。

OOM（Out of Memory）异常常见有以下几个原因：
1）老年代内存不足：java.lang.OutOfMemoryError:Javaheapspace
2）永久代内存不足：java.lang.OutOfMemoryError:PermGenspace
3）代码bug，占用内存无法及时回收。
OOM在这几个内存区都有可能出现，实际遇到OOM时，能根据异常信息定位到哪个区的内存溢出。
可以通过添加个参数-XX:+HeapDumpOnOutMemoryError，让[虚拟机](https://www.zhihu.com/search?q=虚拟机&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"43062139"})在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后分析。

熟悉了JAVA内存管理机制及配置参数，下面是对JAVA应用启动选项调优配置：

```text
JAVA_OPTS="-server -Xms512m -Xmx2g -Xmn1g -XX:PermSize=256m -XX:MaxPermSize=512m -XX:+UseConcMarkSweepGC -XX:+UseParallelGCThreads=8 XX:CMSInitiatingOccupancyFraction=80 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0 -XX:-PrintGC -XX:-PrintGCDetails -XX:-PrintGCTimeStamps -Xloggc:../logs/gc.log"
```

- 设置堆内存最小和最大值，最大值参考历史利用率设置
- 设置GC垃圾收集器为CMS或者G1
- 启用GC日志，方便后期分析

### Java会存在内存泄漏吗？请简单描述？

内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。

内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。

memory leak会最终会导致out of memory

有以下几种情况会发生内存泄露：

* 静态字段保持对象引用
* 在长字符串上调用String.intern（）
* 忘记关闭Stream，在Java 7中，当自动关闭所有类型的Stream的功能被置入到 [try-with-resource clause](https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html)中时，已不会出现。
* 未关闭的连接，例如数据库，FTP服务器等
* 将没有hashCode（）和equals（）的对象添加到HashSet中

### 简述Java垃圾回收机制

在Java开发中，程序员并不需要显式去释放一个对象的内存的，而是由虚拟机自动进行管理。在JVM中，有一个低优先级的垃圾回收线程，在正常情况下这个线程是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的对象集合中，然后进行回收操作。

垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域：

\- 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。

\- 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。

\- 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。

[Java垃圾回收机制 - Matrix海子 - 博客园 (cnblogs.com)](https://www.cnblogs.com/dolphin0520/p/3783345.html)

### GC是什么？为什么要GC?

GC是垃圾收集的意思，[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)处理是开发人员容易出现问题的地方，忘记或者错误地内存回收会导致程序或者系统的不稳定甚至崩溃，Java提供的垃圾回收机制可以自动检测对象是否超过作用域从而达到自动回收的目的。

### 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？

对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。

可以。

程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。强制执行垃圾回收：System.gc()。Runtime.getRuntime().gc()


### 你能保证 GC 执行吗？

不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC的执行。

### Java 中都有哪些引用类型？

强引用、软引用、弱引用、虚引用

* 在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被[垃圾回收](https://so.csdn.net/so/search?q=垃圾回收&spm=1001.2101.3001.7020)机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。
* 软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。
* 弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 [JVM](https://so.csdn.net/so/search?q=JVM&spm=1001.2101.3001.7020) 的内存空间是否足够，总会回收该对象占用的内存。
* 虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。

### 介绍一下强引用、软引用、弱引用、虚引用的区别？

* 强引用：
  * 直接访问目标对象
  * 不会被回收
  * 可能导致内存泄露
* 软引用：
  * 内存充足，不会回收
  * 内存到达阀值，回收
* 弱引用：
  * 具有很短的声明周期
  * 无论内存是否足够，GC发现就会释放
  * GC线程优先级低，不一定及时发现
* 虚引用：
  * 不影响对象生命周期
  * 任何时候都可能回收
  * 用来跟踪回收对象，清理相关资源

### 在Java中，对象什么时候可以被垃圾回收

判断一个对象是否存活有两种方法：引用计数法和可达性分析法

* 引用计数法：
  * 所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加1，引用失效时，计数器就减1。当一个对象的引用计数器为0时，说明此对象没有被其他对象引用，也就是死对象，将会被GC回收。
        缺陷：无法解决循环引用问题，也就是说对象A引用对象B，对象B反过来引用对象A，那么此时A、B对象的引用计数器都不为0，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。
* 可达性分析法：
  *  从一个被称为GC Roots的对象开始往下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。
        可以作为GC Roots的对象有以下几种：
    * 虚拟机栈中引用的对象
    * 方法区类静态属性引用的对象
    *  方法区常量池引用的对象
    * 方法栈JNI引用的对象

当一个对象不可达GC Roots时，这个对象并不会立马被回收，而是处于一个死缓的阶段，如果要真正的回收需要经历两次标记。如果对象在可达性分析中没有与GC Roots的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者已被虚拟机调用过，那么就认为是没有必要的。如果该对象有必要执行finalize()方法，那么这个对象就会放在一个称为F-Queue的队列中，虚拟机会触发一个Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果finalize()方法执行缓慢或者发生了死锁，那么就是造成F-Queue队列一直等待，造成了内存回收系统的崩溃。GC对处于 F-Queue队列中的对象进行第二次标记，这时，该对象将会被移出“即将回收”集合，等待回收。

### 为什么堆要分新生代和老年代呢？

假设一下，如果不分新老代，内存就一整块，垃圾收集器每次都要把那些长期存在的对象，和生命周期很短的对象放在一起回收，一般长生命周期的对象可能跟应用生命周期一致，你基本回收不掉的，比如Spring 框架里面的Bean管理相关的对象（ApplicationContext），整个应用运行期间都存在，这种一般经过几次回收最后都放在老年代，但是如果不区分新老代，每次都一起回收，性能消耗很大。

区分新老代之后，老年代放长期存活的对象，新生代就放生命周期短的对象，老年代对象很稳定，新生代回收不影响老年代，回收效率能大大提高。

### 新生代为什么不用垃圾清除或者垃圾整理算法

若是在新生代使用垃圾清除或者垃圾整理算法，显然不需要对新生代进行分区。

若是采用标记清除算法：会在新生代产生内存碎片，但是新生代是Java 新对象的出生地，内存碎片化显然是我们不想看到的；

若是采用标记整理算法：虽然标记整理可以解决内存碎片化问题，但是考虑到新生代98%的对象都是“朝生夕死”的，对象被回收掉后会产生很多内存碎片，我们移动存活对象的时候需要耗费大量的时间，远不如直接把这2%对象放到另一个地方采用复制算法更加高效。

### 为什么新生代还要分Eden、From、To区域呢？

前面的分析我们已经得出结论：新生代采用复制算法更加高效。

如果没有Survivor区（From + To），Minor GC（新生代回收）过程中，存活的对象直接被送到老年代，这样的话老年代很快被填满，触发Major GC（因为Major GC一般伴随着Minor GC，也可以看做触发了Full GC），Full GC频繁会影响程序的执行和响应速度。

### 为什么要设置两个Survivor区呢？From 和 To

前面的分析我们已经得出结论：新生代采用复制算法更加高效，且需要对新生代进行分区。

主要还是效率问题，假设将新生代分为Eden和Survivor两个区域，显然对Eden区采用复制算法，对Survivor区采用标记整理算法，这样又回到在新生代使用复制算法效率比标记整理效率高的分析。所以需要通过将Survivor区分为From 和 To区解决。

### JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代

Java堆 = 老年代 + 新生代 | 大小比例为1:2，如下
新生代 = Eden + S0 + S1 也称 form和 to

当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor 区。具体参考我的另外一篇：点这里：深入讲解JVM垃圾回收算法思想及全过程）

大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年代；
如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1，熬过了一轮又一轮，若年龄超过一定限制（15），则被晋升到老年态。即长期存活的对象进入老年代。
Minor GC 是清理新生代
Full GC老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – 包括年轻代和老年代。
Major GC 发生在老年代的GC，清理老年区，经常会伴随至少一次Minor GC，比Minor GC慢10倍以上。
Minor GC触发机制：
当年轻代满时就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。
Full GC触发机制：
（1）调用System.gc时，系统建议执行Full GC，但是不必然执行
（2）老年代空间不足
（3）方法区空间不足
（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存
（5）由Eden区、survivor space1（From Space）区向survivor space2（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小
当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载

### JVM中的永久代中会发生垃圾回收吗

而1.7以前的jdk采用的是永久代作为方法区的实现，在1.7及以前的jdk版本，永久代的空间不足也会导致fullGC，
1.7以前，永久代空间如果设小了，就会触发整个堆的一次full
GC（注意是触发堆的full GC），经过这样的一次定位就初步定位到了是由于永久代空间不足导致了堆的full GC

1.8以后由于改成了元空间，它的垃圾回收就不是由java来控制了，元空间的默认情况下内存空间是使用的操作系统的内存空间，所以空间的容量是比较充裕的，不会发生元空间的空间不足问题。

### 说一下 JVM 有哪些垃圾回收算法？

* 标记-清除算法：
  * 该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。
  * 这种垃圾收集算法会带来两个明显的问题：
    1. 效率问题
    2. 空间问题（标记清除后会产生大量不连续的碎片）
* 标记-复制算法：
  * 为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。
  * 问题：
    * 内存空间利用率低
* 标记-整理算法：
  * 根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
* 分代收集算法：
  * 当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。
  * 比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。

### 说一下 JVM 有哪些垃圾回收器？



| **young**            | **Tenured**  | **JVM options**                          |
| -------------------- | ------------ | ---------------------------------------- |
| Serial               | Serial       | -XX:+UseSerialGC                         |
| Parallel Scavenge    | Serial       | -XX:+UseParallelGC -XX:-UseParallelOldGC |
| Parallel Scavenge    | Parallel Old | -XX:+UseParallelGC -XX:+UseParallelOldGC |
| Parallel New或Serial | CMS          | -XX:+UseParNewGC -XX:+UseConcMarkSweepGC |
| G1                   |              | -XX:+UseG1GC                             |

新生代：Serial、Parallel Scavenge、Parallel New
老年代：Serial Old、Parallel Old、CMS
全堆：G1

jvm的垃圾回收器大体上的分类主要包括四种：串行、并行、并发（CMS）和G1。

串行垃圾回收器（Serial）：它为单线程环境设计并且只使用一个线程进行垃圾回收，会暂停所有的用户线程。所以不适合服务器环境。
并行垃圾回收器（Parallel）：多个垃圾回收线程并行工作，此时用户线程是暂停的，适用于科学计算/大数据处理等弱交互场景。
并发垃圾回收器（CMS）：用户线程和垃圾收集线程同时执行（不一定是并行，可能交替执行），不需要停顿用户线程。互联网公司多用它，适用于对响应时间有要求的场景。
G1垃圾回收器：G1垃圾回收器将堆内存分割成不同的区域然后并发的对其进行垃圾回收。

### 详细介绍一下 CMS 垃圾回收器？

CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。CMS 使用的是标记-**[清除](https://outofmemory.cn/tag/18546.html)**的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。

### 新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？

新生代回收器：Serial、ParNew、Parallel Scavenge

老年代回收器：Serial Old、Parallel Old、CMS

新生代回收器一般采用的是复制算法，复制算法效率较高，但是浪费内存

老生代回收器一般采用标记清楚算法，比如最常用的CMS

### 简述分代垃圾回收器是怎么工作的？

分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。

新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：

把 Eden + From Survivor 存活的对象放入 To Survivor 区；
清空 Eden 和 From Survivor 分区；
From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。

每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。

老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程

### 什么时候会触发FullGC？

![Full GC触发条件](https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211152030323.png)

### 内存分配策略

- 静态存储
  是指在编译时就能够确定每个数据目标在运行时的存储空间需求，因而在编译时就可以给它们分配固定的内存空间。 
  这种分配策略要求程序代码中不允许有可变[数据结构](http://lib.csdn.net/base/datastructure)的存在，也不允许有嵌套或者递归的结构出现，因为它们都会导致编译程序无法计算准确的存储空间。
- 栈式存储
  栈式存储分配是动态存储分配，是由一个类似于堆栈的运行栈来实现的，和静态存储的分配方式相反。 
  在栈式存储方案中，程序对数据区的需求在编译时是完全未知的，只有到了运行的时候才能知道，但是规定在运行中进入一个程序模块的时候，必须知道该程序模块所需要的数据区的大小才能分配其内存。和我们在数据结构中所熟知的栈一样，栈式存储分配按照先进后出的原则进行分配。
- 堆式存储
  堆式存储分配专门负责在编译时或运行时，无法确定存储要求的数据结构的内存分配。 
  比如可变长度串和对象实例，堆由大片的可利用块或空闲块组成，堆中的内存可以按照任意顺序分配和释放。

### 简述java内存分配与回收策略以及Minor GC和Major GC？

内存分配：

1. 栈区：栈可分为Java虚拟机和本地方法栈

2. 堆区：堆被所有线程共享，在虚拟机启动时创建，是唯一的目的是存放对象实例，是gc的主要区域。通常可分为两个区块年轻代和年老代。更新一点年轻代可分为Eden区，主要放新创建对象，From survivor 和 To survivor 保存 gc 后幸存下的对象，默认情况下各自占比 8:1:1。

3. 方法区：被所有线程共享，用于存放已被虚拟机加载的信息，常量，静态变量等，是Java虚拟机描述为堆的一个逻辑部分。习惯被称为永久代。

4. 程序计数器：是当前线程所执行的行号指示器，跳转指令等都依赖这个完成，线程私有。

分配规则：

1. 对象优先在 Eden 区分配

2. 大对象直接进入老年代
3. 长期存活对象将进入老年代
4. 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。
5. 空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。

回收：当Eden区没有足够的空间分配时，虚拟机会执行一次Minor GC。

Minor GC通常发生在Eden新生代，因为这个区的对象生存期短，发生频率高，回收速度快。

Major GC发生在老年代，一般触发老年代的GC不会触发Minor GC ,但是通过配置，可以在之前进行一次Minor GC,能加快老年代的回收速度

### 什么是Safe Point?

**Safepoint 可以理解成是在代码执行过程中的一些特殊位置**，当线程执行到这些位置的时候，**线程可以暂停**。在 SafePoint 保存了其他位置没有的**一些当前线程的运行信息，供其他线程读取**。这些信息包括：线程上下文的任何信息，例如对象或者非对象的内部指针等等。我们一般这么理解 SafePoint，就是线程只有运行到了 SafePoint 的位置，他的**一切状态信息，才是确定的**，也只有这个时候，才知道这个线程用了哪些内存，没有用哪些；并且，只有线程处于 SafePoint 位置，这时候对 JVM 的堆栈信息进行修改，例如回收某一部分不用的内存，线程才会感知到，之后继续运行，每个线程都有一份自己的内存使用快照，这时候其他线程对于内存使用的修改，线程就不知道了，只有再**进行到 SafePoint 的时候，才会感知**。

所以，GC 一定需要所有线程同时进入 SafePoint，并停留在那里，等待 GC 处理完内存，再让所有线程继续执。像这种**所有线程进入 SafePoint**等待的情况，就是 Stop the world

[每日一面 - 什么是 Safepoint？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/345034354)

### 简述Java类加载机制?

**类加载本质**

Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行验证、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是Java虚拟机的类加载机制。

**类加载过程**

- **加载**：加载阶段，虚拟机需要完成以下三件事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流；　
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；

其实，虚拟机并没有明确规定类的二进制字节流从哪里获取，这也是Java虚拟机强大的原因，而许多Java技术的基础也是建立在这个基础之上的。比如：

1. 从本地获取
   1. 通常的类加载过程：根据对应类的Jar文件中，直接加载类的二进制字节流；
   2. SPI类加载过程：根据实际使用需要，加载特定的实现策略类；如JDBC针对不同[数据库](https://cloud.tencent.com/solution/database?from=10680)的驱动
2. 从网络获取
   1. Applet应用
3. 运行时计算生成
   1. 动态代理技术：通过反射技术，在运行时生成特定接口的代理类的二进制字节流
4. 从其他文件生成
   1. JSP技术：由JSP文件生成对应的Class类

- **验证**：为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
  - 文件格式验证
  - 元数据验证
  - 字节码验证
  - 符号引用验证
- **准备**：这一阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。
- **解析**：这一阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
- **初始化**：类初始化是类加载的最后一步，初始化阶段才真正开始执行类中定义的Java程序代码，这一阶段主要执行类构造器<clinit>()方法的过程。

![img](https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211152045382.jpeg)

### 描述一下JVM加载Class文件的原理机制?

Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。

类装载方式，有两种 ：

1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，

2.显式装载， 通过class.forname()等方法，显式加载需要的类

### 什么是类加载器，类加载器有哪些?

实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。

主要有一下四种类加载器:

* 启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。
* 扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。
* 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java类。一般来说，Java 应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。
* 用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。

### 说一下类加载的执行过程？

[面试官：请你谈谈Java的类加载过程 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/33509426)

### 什么是双亲委派模型？

一般的说，一个个特定的类加载器它在接到需要加载类的请求时，它会首先查看自己已加载完的类中是否包含这个类，如果有就返回，没有的话就会把加载的任务交给父类加载器加载，以此递归，父类加载器如果可以完成类加载任务，就返回它，当父类加载器无法完成这个加载任务时，才会不得已自己去加载。

### 简单说说你了解的类加载器，可以打破双亲委派吗，怎么打破？

两种方法：

* 自定义类加载器，重写loadClass方法;
* 使用线程上下文类加载器;

双亲委派机制有三次破坏历史：

* 一次破坏
  * 因为双亲委派模型是JDK1.2之后才被引入，而类加载器和抽象类java.lang.ClassLoader则在JDK1.0时就已经存在，所以在面对已存在的用户自定义类加载器的实现代码时，Java设计者引入双亲委派模型时不得不做出一些妥协。在此之前，用户去继承java.lang.ClassLoader的唯一目的就是为了重写loadClass()方法，这是源于虚拟机进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的loadClass()。

* 二次破坏
  * 第二次“破坏”是因为模型自身缺陷所致，双亲委派很好地解决了各个类加载器的基础类的统一问题，那问题就来了，如果基础类又要调用回用户的代码，该怎么办?
    * 例：JNDI服务
    * 它的代码是启动类加载器去加载的，JNDI的目的是为了对资源进行集中管理与查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者的代码，但启动类加载器显然不会知道这些代码。
    * 由此，Java的设计团队引入了一个不怎么优雅的设计：线程上下文类加载器;这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，在创建线程时如果还未设置的话，他会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那么这个类加载器默认就是应用程序类加载器。
    * 这样，JNDI服务就可以去加载它所需要的SPI代码，但这种打通了双亲委派模型层次结构由此来逆向使用类加载器的行为，实际上就已经违背了双亲委派模型的一般性原则!
* 三次破坏
  * 双亲委派模型的第三次“被破坏”源于用户对程序动态性的追求。
  * OSGi实现模块化热部署的核心在于它自定义的类加载器机制的实现。所有的程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉来实现代码的热替换。在OSGi幻境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当受到类加载请求时，OSGi将按照下面的顺序进行类搜索：
    * 把java.*开头的类委派给父类加载器加载。
    * 不然，把委派列表名单内的类委派给父类加载器加载
    * 不然，把Import列表中的类委派给Export这个类的Bundle的类加载器加载。
    * 不然，就查找当前Bundle的ClassPath，并使用自己的类加载器加载。
    * 不然，就查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。
    * 不然，就查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。
    * 不然，类加载器失败。

### 说一下 JVM 调优的工具？

[JVM调优工具详解_我还在等天黑，的博客-CSDN博客_jvm调优工具](https://blog.csdn.net/qq_49281137/article/details/109795485)

### 常用的 JVM 调优的参数都有哪些？

**（1）-Xms20M**

表示设置JVM启动内存的最小值为20M，必须以M为单位

**（2）-Xmx20M**

表示设置JVM启动内存的最大值为20M，必须以M为单位。将-Xmx和-Xms设置为一样可以避免JVM内存自动扩展。大的项目-Xmx和-Xms一般都要设置到10G、20G甚至还要高

**（3）-verbose:gc**

表示输出虚拟机中GC的详细情况

**（4）-Xss128k**

表示可以设置虚拟机栈的大小为128k

**（5）-Xoss128k**

表示设置本地方法栈的大小为128k。不过HotSpot并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说这个参数是无效的

**（6）-XX:PermSize=10M**

表示JVM初始分配的永久代（方法区）的容量，必须以M为单位

**（7）-XX:MaxPermSize=10M**

表示JVM允许分配的永久代（方法区）的最大容量，必须以M为单位，大部分情况下这个参数默认为64M

**（8）-Xnoclassgc**

表示关闭JVM对类的垃圾回收

**（9）-XX:+TraceClassLoading**

表示查看类的加载信息

**（10）-XX:+TraceClassUnLoading**

表示查看类的卸载信息

**（11）-XX:NewRatio=4**

表示设置 年轻代（包括Eden和两个Survivor区）/老年代 的大小比值为1：4，这意味着年轻代占整个堆的1/5

**（12）-XX:SurvivorRatio=**8

表示设置2个Survivor区：1个Eden区的大小比值为2:8，这意味着Survivor区占整个年轻代的1/5，这个参数默认为8

**（13）-Xmn20M**

表示设置年轻代的大小为20M

**（14）-XX:+HeapDumpOnOutOfMemoryError**

表示可以让虚拟机在出现内存溢出异常时Dump出当前的堆内存转储快照

**（15）-XX:+UseG1GC**

表示让JVM使用G1垃圾收集器

**（16）-XX:+PrintGCDetails**

表示在控制台上打印出GC具体细节

**（17）-XX:+PrintGC**

表示在控制台上打印出GC信息

**（18）-XX:PretenureSizeThreshold=3145728**

表示对象大于3145728（3M）时直接进入老年代分配，这里只能以字节作为单位

**（19）-XX:MaxTenuringThreshold=1**

表示对象年龄大于1，自动进入老年代,如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代被回收的概率。

**（20）-XX:CompileThreshold=1000**

表示一个方法被调用1000次之后，会被认为是热点代码，并触发即时编译

**（21）-XX:+PrintHeapAtGC**

表示可以看到每次GC前后堆内存布局

**（22）-XX:+PrintTLAB**

表示可以看到TLAB的使用情况

**（23）-XX:+UseSpining**

开启自旋锁

**（24）-XX:PreBlockSpin**

更改自旋锁的自旋次数，使用这个参数必须先开启自旋锁

**（25）-XX:+UseSerialGC**

表示使用jvm的串行垃圾回收机制，该机制适用于丹cpu的环境下

**（26）-XX:+UseParallelGC**

表示使用jvm的并行垃圾回收机制，该机制适合用于多cpu机制，同时对响应时间无强硬要求的环境下，使用-XX:ParallelGCThreads=<N>设置并行垃圾回收的线程数，此值可以设置与机器处理器数量相等。

**（27）-XX:+UseParallelOldGC**

表示年老代使用并行的垃圾回收机制

**（28）-XX:+UseConcMarkSweepGC**

表示使用并发模式的垃圾回收机制，该模式适用于对响应时间要求高，具有多cpu的环境下

 **（29）-XX:MaxGCPauseMillis=100**

设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。

**（30）-XX:+UseAdaptiveSizePolicy**

### 调优命令有哪些？

* jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。
* jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。
* jmap，JVM Memory Map命令用于生成heap dump文件
* jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看
* jstack，用于生成java虚拟机当前时刻的线程快照。
* jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。

### 怎么打印线程栈信息？

jstack可以得知当前线程的运行情况

* 安装jstack等命令集，jstack是开发版本jdk的一部分，不是开发版的有可能找不到：yum install -y  java-1.8.0-openjdk-devel
* 查看要打印[堆栈](https://so.csdn.net/so/search?q=堆栈&spm=1001.2101.3001.7020)的java进程ID：jps -l
* 打印堆栈：sudo -u admin jstack pid  > jstack.txt

> 特别要注意的是jstack需要使用与进程一致的用户才能正确导出堆栈，否则会报错如下
>
> Unable to open socket file: target process not responding or HotSpot VM not loaded