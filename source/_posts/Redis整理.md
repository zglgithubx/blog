---
title: Redis整理
date: 2022-12-04 17:41:16
categories: 数据库
tags: Redis
---
Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。
<!-- more -->
### Redis的数据类型有哪些？

数据库键总是一个字符串，值是多种数据类型。

支持的数据类型有：

- 字符串 strings
- 散列 hashes
- 列表 lists
- 集合 sets
- 有序集合 sorted sets
- bitmaps
- hyperloglogs
- 地理空间 geospatial 索引半径查询

### Redis持久化方式

Redis提供了两种不同的持久化方法将数据保存到硬盘里面。

**RDB快照持久化**：将Redis某一时刻存在的所有数据都写入硬盘。

**AOF持久化**：AOF的全称叫append-only file，中文意思是只追加文件。当使用AOF持久化方式的时候，Redis执行写命令的时候，将被执行的写命令复制到硬盘里面，说的通俗一点就是写日志。

#### 快照持久化

Redis通过创建快照来获得存储在内存里面的数据在某个时间节点上的副本。

触发机制-主要三种方式

1. save（同步）
2. bgsave（异步）
3. 自动

**save命令**：客户端向Redis发送save命令来创建一个快照文件。

![image-20221128155336676](https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211281553756.png)

执行save命令的时候，如果存在老的快照文件，新的将会替换老的。

**bgsave命令**：客户端向Redis发送bgsave命令，Redis调用fork创建一个子进程，然后子进程负责将快照写入硬盘，而父进程则继续处理命令请求。

![image-20221128155416297](https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211281554372.png)

save命令和bgsave命令对比：

| 命令     | save             | bgsave             |
| -------- | ---------------- | ------------------ |
| IO类型   | 同步             | 异步               |
| 是否阻塞 | 是               | 是                 |
| 复杂度   | O(n)             | O(n)               |
| 优点     | 不会消耗额外内存 | 不阻塞客户端命令   |
| 缺点     | 阻塞客户端命令   | 需要fork，消耗内存 |

**自动生成**：通过配置，满足任何一个条件就会创建快照文件。

![image-20221128155438270](https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211281554343.png)

快照持久化选项：

```
多久执行一次自动快照操作，60s之内有1000次操作写入时执行
save 60 1000
创建快照失败后是否仍然继续执行写命令
stop-writes-on-bgsave-error no
是否对快照文件进行压缩
rdbcompression yes
命名硬盘上的快照文件
dbfilename dump.rdb
```

最佳配置：

```
dbfilename dump-${port}.rdb
dir /bigdiskpath
stop-writes-on-bgsave-error yes
rdbcompression yes
rdbchecksum yes
```

#### 快照持久化现存问题

**耗时、耗性能**：通过bgsave命令进行持久化的的时候，需要fork一个子进程，如果数据量很大的话，需要的内存也会相应的变大，内存的占用会导致Redis性能降低。

**不可控、丢失数据**：举个例子，上一次创建快照是11:00开始创建并创建成功。如果Redis在12:00开始创建新的快照，如果系统在未完成创建快照之前崩溃，11:00-12:00写入的数据将会丢失；如果系统在快照创建完成之后崩溃，那么12:00之后，创建快照的过程中的数据将会丢失。

#### AOF持久化

AOF持久化将被执行的写命令写到AOF文件的末尾，以达到记录数据的目的。Redis只要从头到尾重新执行一次AOF所有的命令就可以恢复数据。

AOF的三种策略：

**always：每条Redis写命令都同步写入硬盘。**

**everysec：每秒执行一次同步，将多个命令写入磁盘。**

**no：由操作系统决定何时同步。**

三种策略对比：生产环境中需要根据实际的需求进行选择。

| 命令 | always                              | everysec      | no     |
| ---- | ----------------------------------- | ------------- | ------ |
| 优点 | 不丢失数据                          | 每秒一次fsync | 不用管 |
| 缺点 | IO开销较大，一般的SATA盘只有几百TPS | 丢1s数据      | 不可控 |

#### AOF重写

随着Redis的运行，被执行的写命令不断同步到AOF文件中，AOF文件的体积越来越大，极端情况将会占满所有的硬盘空间。如果AOF文件体积过大，还原的过程也会相当耗时。为了解决AOF文件不断膨胀的问题，需要移除AOF文件中的冗余命令来重写AOF。

#### 快照持久化和AOF持久化的对比和选择

##### 对比

| 命令       | 快照持久化 | AOF持久化    |
| ---------- | ---------- | ------------ |
| 启动优先级 | 低         | 高           |
| 体积       | 小         | 大           |
| 恢复速度   | 快         | 慢           |
| 数据安全性 | 丢数据     | 根据策略决定 |
| 轻重       | 重         | 轻           |

##### 选择

在实际生产环境中，根据数据量、应用对数据的安全要求、预算限制等不同情况，会有各种各样的持久化策略；如完全不使用任何持久化、使用快照持久化或AOF持久化的一种，或同时开启快照持久化和AOF持久化等。此外，持久化的选择必须与Redis的主从策略一起考虑，因为主从复制与持久化同样具有数据备份的功能，而且主机master和从机slave可以独立的选择持久化方案。

（1）如果Redis中的数据完全丢弃也没有关系（如Redis完全用作DB层数据的cache），那么无论是单机，还是主从架构，都可以不进行任何持久化。

（2）在单机环境下（对于个人开发者，这种情况可能比较常见），如果可以接受十几分钟或更多的数据丢失，选择快照持久化对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF。

（3）但在多数情况下，我们都会配置主从环境，slave的存在既可以实现数据的热备，也可以进行读写分离分担Redis读请求，以及在master宕掉后继续提供服务。在这种情况下，一种可行的做法是：master：完全关闭持久化，这样可以让master的性能达到最好slave：关闭快照持久化，开启AOF（如果对数据安全要求不高，开启快照持久化关闭AOF也可以），并定时对持久化文件进行备份（如备份到其他文件夹，并标记好备份的时间）；然后关闭AOF的自动重写，然后添加定时任务，在每天Redis闲时（如凌晨12点）调用bgrewriteaof。

### [Redis高可用实现方案](https://www.cnblogs.com/zhonglongbo/p/13128955.html)

有三种：主从模式、哨兵模式、集群模式

#### 主从模式

主从实例部署在不同的物理服务器上，根据公司的基础环境配置，可以实现同时对外提供服务和读写分离策略。

**优点：**

* 高可靠性：一方面，采用双机主备架构，能够在主库出现故障时自动进行主备切换，从库提升为主库提供服务，保证服务平稳运行；另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和数据异常丢失的问题；
* 读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。

**缺点：**

* 故障恢复复杂，如果没有RedisHA系统（需要开发），当主库节点出现故障时，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其它从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐；
* 主库的写能力受到单机的限制，可以考虑分片；
* 主库的存储能力受到单机的限制，可以考虑Pika；
* 原生复制的弊端在早期的版本中也会比较突出，如：Redis复制中断后，Slave会发起psync，此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时可能会造成毫秒或秒级的卡顿；又由于COW机制，导致极端情况下的主库内存溢出，程序异常退出或宕机；主库节点生成备份文件导致服务器磁盘IO和CPU（压缩）资源消耗；发送数GB大小的备份文件导致服务器出口带宽暴增，阻塞请求，建议升级到最新版本。

#### 哨兵模式

![img](https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211281732149.jpeg)

如图，哨兵节点由两部分组成，哨兵节点和数据节点：

- 哨兵节点：哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的redis节点，不存储数据。
- 数据节点：主节点和从节点都是数据节点。

访问redis集群的数据都是通过哨兵集群的，哨兵监控整个redis集群。

一旦发现redis集群出现了问题，比如刚刚说的主节点挂了，从节点会顶上来。但是主节点地址变了，这时候应用服务无感知，也不用更改访问地址，因为哨兵才是和应用服务做交互的。

Sentinel 很好的解决了故障转移，在高可用方面又上升了一个台阶，当然Sentinel还有其他功能。

比如 **主节点存活检测**、**主从运行情况检测**、**主从切换**。

Redis的Sentinel最小配置是 **一主一从**。

##### 哨兵模式的优缺点

 优点：

- 哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。
- 主从可以自动切换，系统更健壮，可用性更高。
- Sentinel 会不断的检查 主服务器 和 从服务器 是否正常运行。当被监控的某个 Redis 服务器出现问题，Sentinel 通过API脚本向管理员或者其他的应用程序发送通知。

 缺点：

- Redis较难支持在线扩容，对于集群，容量达到上限时在线扩容会变得很复杂。

#### 集群模式

主从不能解决故障自动恢复问题，哨兵已经可以解决故障自动恢复了，那到底为啥还要集群模式呢？

主从和哨兵都还有另外一些问题没有解决，单个节点的存储能力是有上限，访问能力是有上限的。

Redis Cluster 集群模式具有 **高可用**、**可扩展性**、**分布式**、**容错** 等特性。

##### Cluster 集群模式的原理

通过数据分片的方式来进行数据共享问题，同时提供数据复制和故障转移功能。

之前的两种模式数据都是在一个节点上的，单个节点存储是存在上限的。集群模式就是把数据进行分片存储，当一个分片数据达到上限的时候，就分成多个分片。

##### 数据分片怎么分？

集群的键空间被分割为16384个slots（即hash槽），通过hash的方式将数据分到不同的分片上的。

```ini
HASH_SLOT = CRC16(key) & 16384 
```

CRC16是一种循环校验算法。这里用了**位运算**得到取模结果，位运算的速度高于取模运算。

### Redis实现分布式锁

1、什么是分布式锁

- 当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。
- 与单机模式下的锁不仅需要保证进程可见，还需要考虑进程与锁之间的网络问题。
- 分布式锁还是可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存如 Redis、Memcache。至于利用数据库、文件等做锁与单机的实现是一样的，只要保证标记能互斥就行。

2、分布式锁需要具备哪些条件

* 互斥性：在任意一个时刻，只有一个客户端持有锁。
* 无死锁：即便持有锁的客户端崩溃或者其他意外事件，锁仍然可以被获取。
* 高可用、高性能的获取和释放锁
* 具备可重入特性

Redis中可以使用SETNX命令实现分布式锁。返回值：设置成功，返回 1 。设置失败，返回 0 。

* 当且仅当 key 不存在，将 key 的值设为 value。
* 若给定的 key 已经存在，则 SETNX 不做任何动作

SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。

expire: EXPIRE key seconds

为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除

### 如何保证缓存与数据库的一致性

删除缓存有两种方式：

先删除缓存，再更新数据库。解决方案是使用延迟双删。

先更新数据库，再删除缓存。解决方案是消息队列或者其他 binlog 同步，引入消息队列会带来更多的问题，并不推荐直接使用。

针对缓存一致性要求不是很高的场景，那么只通过设置超时时间就可以了。

其实，如果不是很高的并发，无论你选择先删缓存还是后删缓存的方式，都几乎很少能产生这种问题.

#### 先删缓存，再更新数据库

1.先删除缓存，数据库还没有更新成功，此时如果读取缓存，缓存不存在，去数据库中读取到的是旧值，发生缓存不一致。

延时双删的方案思路是，为了避免更新数据库的时候，其他线程读取数据库，将旧值缓存到Redis，所有采用更新数据库之后Sleep一段时间再删除。

Sleep 的时间要对业务读写缓存的时间做出评估，Sleep 时间大于读写缓存的时间即可。

流程如下：

1. 线程1删除缓存，然后去更新数据库。
2. 线程2来读缓存，发现缓存已经被删除，所以直接从数据库中读取，这时候由于线程1还没有更新完成，所以读到的是旧值，然后把旧值写入缓存。
3. 线程1，根据估算的时间，Sleep，由于 Sleep 的时间大于线程2读数据+写缓存的时间，所以缓存被再次删除。
4. 如果还有其他线程来读取缓存的话，就会再次从数据库中读取到最新值。

#### 先更新数据库，再删除缓存

更新数据库成功，如果删除缓存失败或者还没有来得及删除，那么，其他线程从缓存中读取到的就是旧值，还是会发生不一致。

解决方案：

先更新数据库，成功后往消息队列发消息，消费到消息后再删除缓存，借助消息队列的重试机制来实现，达到最终一致性的效果

这个解决方案其实问题更多:

1. 引入消息中间件之后，问题更复杂了，怎么保证消息不丢失更麻烦。
2. 就算更新数据库和删除缓存都没有发生问题，消息的延迟也会带来短暂的不一致性，不过这个延迟相对来说还是可以接受的。

为了解决缓存一致性的问题单独引入一个消息队列，太复杂了。

其实，一般大公司本身都会有监听 binlog 消息的消息队列存在，主要是为了做一些核对的工作。

这样，我们可以借助监听 binlog 的消息队列来做删除缓存的操作。这样做的好处是，不用你自己引入，侵入到你的业务代码中，中间件帮你做了解耦，同时，中间件的这个东西本身就保证了高可用。

当然，这样消息延迟的问题依然存在，但是相比单纯引入消息队列的做法更好一点。

而且，如果并发不是特别高的话，这种做法的实时性和一致性都还算可以接受的。

#### 其他解决方案

设置缓存过期时间

每次放入缓存的时候，设置一个过期时间，比如5分钟，以后的操作只修改数据库，不操作缓存，等待缓存超时后从数据库重新读取。

如果对于一致性要求不是很高的情况，可以采用这种方案。

这个方案还会有另外一个问题，就是如果数据更新的特别频繁，不一致性的问题就很大了。

在实际生产中，我们有一些活动的缓存数据是使用这种方式处理的。

因为活动并不频繁发生改变，而且对于活动来说，短暂的不一致性并不会有什么大的问题。

### Redis的定时机制如何实现的，有哪些弊端，你将如何改进这个弊端？

Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：文件事件和时间事件。Redis的定时机制就是借助时间事件

### CAP

* 强一致性：即在分布式系统中的同一数据多副本情形下，对于数据的更新操作体现出的效果与只有单份数据是一样的。
* 可用性：客户端在任何时刻对大规模数据系统的读写操作都应该保证在限定延时内完成
* 分区容错性：在大规模分布式数据系统中，网络分区现象，即分区间的机器无法进行网络通信的情况是必然发生的，所以系统应该能够在这种情况下仍然继续工作。

一般在网络环境下，运行环境出现网络分区是不可避免的，所以系统必须具备分区容错特性，所以一般在这种场景下设计大规模分布式系统时，往往在AP和CP中进行权衡和选择。

#### 为什么CAP三者不可兼得？

在分布式的环境下，P是必须要有的。现在只剩下C和A是否可以兼得了，如果在分布式系统中数据没有副本，那么系统必须满足强一致条件，因为只有独本数据，不会出现数据不一致的问题，此时C和P都具备。

如果服务器宕机，那必须会导致某些数据是不能访问，那么A就不符合了。

### 如果出现一个key的Value较大时的情况？

该对象需要每次都整存整取: 可以尝试将对象分拆成几个key-value， 使用multiGet获取值，这样分拆的意义在于分拆单次操作的压力，将操作压力平摊到多个redis实例中，降低对单个redis的IO影响；
该对象每次只需要存取部分数据: 可以像第一种做法一样，分拆成几个key-value，也可以将这个存储在一个hash中，每个field代表一个具体的属性，使用hget,hmget来获取部分的value，使用hset，hmset来更新部分属性。

### 跳表

将单链表先进行排序，然后针对 有序链表 为了实现高效的查找，可以使用跳表这种数据结构。

其根本思想是 二分查找 的思想。

跳表的前提条件是 针对 有序的单链表 ，实现高效地查找，插入，删除。

Redis中的 有序集合 sorted set 就是用跳表实现的。

### Redis线程模型

Redis基于Reactor模式开发了网络事件处理器，，它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。

* 文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。
* 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。

文件事件处理器以单线程方式运行， 通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性

### Redis为什么这么快？

1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；

2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；

3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

4、使用多路I/O复用模型，非阻塞IO；这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程

### Redis6.0多线程的实现机制

流程简述如下：

1、主线程负责接收建立连接请求，获取 socket 放入全局等待读处理队列

2、主线程处理完读事件之后，通过 RR(Round Robin) 将这些连接分配给这些 IO 线程

3、主线程阻塞等待 IO 线程读取 socket 完毕

4、主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但并不执行

5、主线程阻塞等待 IO 线程将数据回写 socket 完毕

6、解除绑定，清空等待队列

设计有如下特点：

1、IO 线程要么同时在读 socket，要么同时在写，不会同时读或写

2、IO 线程只负责读写 socket 解析命令，不负责命令处理

Redis的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。所以我们不需要去考虑控制 key、lua、事务，LPUSH/LPOP 等等的并发及线程安全问题。


### Redis过期键的删除策略

三种不同的删除策略：

* 立即删除。
  * 在设置键的过期时间时，创建一个定时器，当过期时间达到时，由时间处理器自动执行键的删除操作。
  * 该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量
* 惰性删除。
  * 键过期了就不管。每次从dict字典中按key取值时，先检查此key是否已经过期，如果过期了就删除该键，如果没过期，就返回键值。
  * 该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。
  * db.c/expireIfNeeded函数实现
* 定时删除。
  * 每隔一段时间，对expires字典进行检查，删除里面的过期键。\
  * 该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。
  * redis.c/activeExpireCycle函数实现

### Redis的内存用完会发生什么？

如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。

### Redis事务

redis是怎么保证多线程进来的多个命令，保持顺序进入单线程的命令处理模块的

multi可以在客户端打包要执行的命令批量的提交到服务端，从而减少每条指令每次发送的网络通讯

multi指令的用途是保证multi和exec之间的所有指令不被其他客户端的指令打扰的一个个执行

服务端收到multi指令后，会一直等到exec指令到达，才将所有的指令一起放入队列执行

事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。

Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。Redis提供的事务是将多个命令打包，然后一次性、按照先进先出的顺序有序的执行。

在执行过程中不会被打断*（在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中），当事务队列中的所以命令都被执行（无论成功还是失败）*完毕之后，事务才会结束。

Redis不保证原子性：

原子性：数据库中的某个事务A中要更新t1表、t2表的某条记录，当事务提交，t1、t2两个表都被更新，若其中一个表操作失败，事务将回滚

Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。

### 缓存雪崩

缓存雪崩：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。

1、避免缓存集中失效，

2、增加互斥锁，控制数据库请求，重建缓存。

3、提高缓存的HA，如：redis集群。

缓存数据的过期时间设置随机(不同的key设置不同的超时时间)，防止同一时间大量数据过期现象发生。
一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。增加互斥锁，控制数据库请求，重建缓存。
给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。

### 缓存穿透

key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。

最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。


### 缓存击穿

key对应的数据存在，但在redis中过期（但数据库中有的数据），此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端数据库加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端数据库压垮。

解决方案

- 设置热点数据永远不过期。
- 加互斥锁

### 缓存预热

缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！

解决方案

* 直接写个缓存刷新页面，上线时手工操作一下；
* 数据量不大，可以在项目启动的时候自动进行加载；
* 定时刷新缓存；

### 布隆过滤器

bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小

算法：
1. 首先需要k个hash函数，每个函数可以把key散列成为1个整数
2. 初始化时，需要一个长度为n比特的数组，每个比特位初始化为0
3. 某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1
4. 判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。

优点：不需要存储key，节省空间

缺点：
1. 算法判断key在集合中时，有一定的概率key其实不在集合中
2. 无法删除

典型的应用场景：

在程序的世界中，布隆过滤器是程序员的一把利器，利用它可以快速地解决项目中一些比较棘手的问题。

如网页 URL 去重、垃圾邮件识别、大集合中重复元素的判断和缓存穿透等问题。

布隆过滤器的典型应用有：

- 数据库防止穿库。 Google Bigtable，HBase 和 Cassandra 以及 Postgresql 使用BloomFilter来减少不存在的行或列的磁盘查找。避免代价高昂的磁盘查找会大大提高数据库查询操作的性能。
- 业务场景中判断用户是否阅读过某视频或文章，比如抖音或头条，当然会导致一定的误判，但不会让用户看到重复的内容。
- 缓存宕机、缓存击穿场景，一般判断用户是否在缓存中，如果在则直接返回结果，不在则查询db，如果来一波冷数据，会导致缓存大量击穿，造成雪崩效应，这时候可以用布隆过滤器当缓存的索引，只有在布隆过滤器中，才去查询缓存，如果没查询到，则穿透到db。如果不在布隆器中，则直接返回。
- WEB拦截器，如果相同请求则拦截，防止重复被攻击。用户第一次请求，将请求参数放入布隆过滤器中，当第二次请求时，先判断请求参数是否被布隆过滤器命中。可以提高缓存命中率。Squid 网页代理缓存服务器在 cache digests 中就使用了布隆过滤器。Google Chrome浏览器使用了布隆过滤器加速安全浏览服务
- Venti 文档存储系统也采用布隆过滤器来检测先前存储的数据。
- SPIN 模型检测器也使用布隆过滤器在大规模验证问题时跟踪可达状态空间。
### Redis内存不足如何解决？

1、增加内存

2、内存淘汰策略

* 在 Redis 4.0 版本之前有 6 种策略，4.0 增加了 2种，主要新增了 LFU 算法。
  * volatile-lru，针对设置了过期时间的key，使用lru算法进行淘汰。
  * allkeys-lru，针对所有key使用lru算法进行淘汰。
  * volatile-lfu，针对设置了过期时间的key，使用lfu算法进行淘汰。
  * allkeys-lfu，针对所有key使用lfu算法进行淘汰。
  * volatile-random，从所有设置了过期时间的key中使用随机淘汰的方式进行淘汰。
  * allkeys-random，针对所有的key使用随机淘汰机制进行淘汰。
  * volatile-ttl，针对设置了过期时间的key，越早过期的越先被淘汰。
  * noeviction（默认），不会淘汰任何数据，当使用的内存空间超过 maxmemory 值时，再有写请求来时返回错误。

3、使用集群

### Redis实现记录访客量？

Bitmap

HLL（HyperLogLog）

