---
title: JUC整理
categories: Java
tags: 并发编程
abbrlink: 55960
date: 2022-11-26 10:25:04
---

JUC实际上就是我们对于jdk中java.util .concurrent 工具包的简称。这个包下都是Java处理线程相关的类，自jdk1.5后出现。

<!-- more -->

### Java中的线程的生命周期大体可分为5种状态。

1. **新建(NEW)**：新创建了一个线程对象。

2. **可运行(RUNNABLE)**：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。

3. **运行(RUNNING)**：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。

4. **阻塞(BLOCKED)**：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： 

> (一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。
> (二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。
> (三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。

5. **死亡(DEAD)**：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。

### 什么是 JUC ？

juc就是java.util.concurrent工具包的简称。这是一个处理线程的工具包，从jdk1.5开始出现

目的就是为了更好的支持高并发任务。

分类：

![image-20221121170957508](https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211211709758.png)

![image-20221121171109563](https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211211711669.png)

### 什么是Java线程模型？

Java字节码运行在JVM中，而JVM运行在操作系统上，JVM想要进行线程创建和回收的这种操作时，势必需要调用操作系统的相关接口。也就是说，JVM线程与操作系统线程之间存在着某种映射关系，这两种不同维度的线程之间的规范与协议，就是线程模型。

### 为什么需要Java线程模型？

正如我们现在不常用汇编语言进行开发，而是使用更加简单容易上手的高级语言一样，这是一种自下而上的抽象。

JVM线程对不同操作系统上的原生线程进行了高级抽象，使开发者大多数情况下可以不同关注下层细节，而只要专注上层开发。

JVM线程模型有三种类型：一对一，多对一，多对多。

### 线程和进程区别？

#### 概念

进程是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。

在Linux中，线程又称为轻量级进程。线程是抽象概念（KLT，内核线程），因为Linux内部没有专门为线程定义的数据结构和算法，所以Linux去实现"线程"的方式是“轻量级进程”。

#### 区别

* 地址空间：一个Liunx进程拥有自己独立的地址空间，而一个轻量级进程没有自己独立的地址空间，只能共享同一个轻量级进程组下的地址空间。
* 资源：线程共享本进程的资源如内存、I/O、cpu等，不利于资源的管理和保护，而进程之间的资源是独立的，能很好的进行资源管理和保护。
* 健壮性：多进程要比多线程健壮，一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。
* 执行过程：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口，执行开销大。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，执行开销小。

### 什么是锁？

在并发环境下，会出现多个线程对同一个资源进行争抢的情况，假设A线程对资源正在进行修改，此时B线程持又对资源进行修改，这就可能会导致数据不一致的问题。为了解决这个问题，便引入了锁机制，通过一种抽象的”锁“来对资源进行锁定，当一个线程持有”锁“的时候，其他线程必须等待”锁“，本质上就是在共享资源上对线程进行一种串行化控制。

### Java锁机制是如何设计的？

在Java中，主要采用了两种实现方式：1.基于Object的悲观锁。2.基于CAS的乐观锁。

概括的解释就是：在Java中，每个Object，也就是每个对象都拥有一把锁，这把锁存放在对象头中，记录了当前对象被哪个线程占用。

### 对象和对象头的结构分别是什么？

#### 对象结构：

* 对象头：存放了一些对象本身的运行时信息
* 实例数据：初始化对象时设定的属性和状态内容
* 对齐填充字段：是为了满足“java对象大小是8字节的倍数”，这一条件而设计的，为对象对齐填充了一些无用字节。

#### 对象头结构：

* Mark Word：存储了当前对象的运行时状态信息，比如HashCode，锁状态标志、指向锁记录的指针、偏向线程ID、锁标志位等。
  * ![image-20221119110240837](https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211191102924.png)
* Class Pointer：是一个指针，指向当前对象类型所在方法区中的Class信息。

### Synchronized

在Java中，synchronized关键字可以用来同步线程，synchronized被编译后会生成monitorenter和monitorexit两个字节码指令，依赖这两个指令来进行线程同步。

synchronzied的实现是依赖于操作系统的Mutex Lock（互斥锁）来实现的。Java线程事实上是对操作系统线程的映射，所以每当挂起或唤醒一个线程都要切换到操作系统的内核态，这个操作算是比较重量级的。所以使用synchronzied会有性能问题。

从Java6开始，synchronzied进行了优化，引入了：偏向锁、轻量级锁的概念。因此对象锁一共有四种状态，从低到高分别是：无锁、偏向锁、轻量级锁、重量级锁，分别对象了Mark word中锁标记位的四种状态。

### 对象锁的四种状态

#### 无锁

无锁顾名思义就是没有对资源进行操作系统级别的锁定。无锁的两种情况。

1、某种资源不会出现在多线程环境下，或者说即使出现在多线程环境下也不会出现线程竞争的情况。

2、资源会被竞争，但是不使用操作系统同步原语对共享资源进行锁定，而是通过一些其他机制来控制同步。比如CAS，通过诸如这种函数级别的锁，我们可以进行["无锁"编程](https://www.cnblogs.com/jerry-pgm/p/15265356.html#五无锁编程实现)。

#### 偏向锁

假如一个对象被加锁了，但在实际运行时，只有一条线程会获取这个对象锁，那么我们最理想的方式，是不要通过系统状态切换，只在用户态解决这个问题。简单的理解就是对象锁能够认识这个线程，只要是这个线程过来，那么对象就直接把锁交出去。我们可以认为这个对象锁偏爱这个线程，所以被称为“偏向锁”。

假如出现多个线程都在竞争锁，那么偏向锁将会升级为轻量级锁。

#### 轻量级锁

当一个线程想要获得某个对象的锁时，假如看到锁标志位为00，那么就知道它是轻量级锁，这时，线程会在自己的虚拟机栈中开辟一块被称为“Lock Record”的空间。

Lock Record中存放的是对象头Mark word的副本以及Owner指针。线程通过CAS去尝试获取锁，一旦获得，那么将会复制该对象的Mark Word到虚拟机栈的Lock Record中，并且将Lock Record中的Owner指针指向该对象锁。

并且在对象的Mark Word 中的前30bit将生成一个指针，指向持有该对象锁的线程虚拟机栈中的Lock Record。这样就实现了线程和对象锁的绑定。

当有其他线程也想要获取这个对象，此时需要自旋等待。

> 什么叫自旋？可以理解为一种轮询，其他想要获取对象锁的线程自己不断在循环尝试去看一下锁有没有释放，如果被释放了，那么就获取，其他想要获取对象锁的线程自己不断在循环尝试去看下锁有没有被释放，如果被释放了，那么就获取，如果没有释放那么就进行下一轮循环，这种方式区别于被操作系统挂起阻塞，因为如果对象说很快被释放的话，自旋去获取锁完全在用户空间解决，不需要进行系统中断和现场回复，所以它的效率更高。

如果长时间自旋，将会浪费CPU资源，于是出现了一种叫做“适应性自旋”的优化，简单来说就是自旋的时间不再固定，而是由上一次在同一个锁上的自旋时间及锁的状态来决定。比如在同一个锁上，目前正在自旋等待的线程刚成功获取锁，但是锁目前被其他线程持有，那么虚拟机就会认为下次自旋很有可能会再次成功，进而它将允许更长的自旋时间。

一旦自旋等待的线程数超过1个，那么轻量级锁将会升级为重量级锁。

#### 重量级锁

如果对象锁状态被标记为重量级锁，那么就需要通过Monitor来对线程进行控制，此时将会使用同步原语来锁定资源，对线程的控制也最为严格。

#### 为什么要定义这四种状态？

目的就是尽量在用户空间内去完成锁的获取与释放，因为一旦进入“重量级锁”状态，那么将会调用内核空间，产生较大开销。

### 悲观锁和乐观锁

#### 悲观锁

* 含义：
  * 具有强烈的独占和排他特性，对数据被外界修改保持保守态度，因此在真个数据处理过程中，将数据处于锁定状态。
* 应用：关系型数据库的航说、表锁，读锁、写锁

#### 乐观锁

* 含义：乐观的认为，每次去拿数据时候都认为别人不会修改，所以不会上锁，但更新的时候回判断在此期间有没有别人去更新这个数据，可以使用版本号等机制。
* 使用场景：适用于多读的应用类型，可以提高吞吐量
* 实现：使用版本号，或者使用CAS操作

### 如何实现CAS的原子性？

各种不同架构的CPU都提供了指令级的CAS原子操作。比如在x86架构下，通过cmpxchg指令支持CAS，在ARM下，通过LL/SC来实现CAS。

### 如果利用CAS特性，来进行乐观锁编程？

* 使用AtomicXXX类（底层基于CAS实现的）
* 使用Unsafe类下的compareandSwapInt方法

### 什么是AQS？

AQS是队列同步器AbstractQueueSynchronizer的简写，它是用来构建锁和其他同步组件的基础框架，它定义了一个全局的int 型的state变量，通过内置的FIFO（先进先出）队列来完成资源竞争排队的工作。

### AQS原理

`AQS`中 维护了一个`volatile int state`（代表共享资源）和一个`FIFO`线程等待队列（多线程争用资源被阻塞时会进入此队列）。

这里`volatile`能够保证多线程下的可见性，当`state=1`则代表当前对象锁已经被占有，其他线程来加锁时则会失败，加锁失败的线程会被放入一个`FIFO`的等待队列中，并且会被`UNSAFE.park()`操作挂起，等待其他获取锁的线程释放锁才能够被唤醒。

另外`state`的操作都是通过`CAS`来保证其并发修改的安全性。

### 如何修改和访问同步器的状态？

- getState:获取当前同步状态
- setState:设置当前同步状态
- compareAndSetState:使用CAS设置当前状态，该方法能保证状态设置的原子性。

### AQS提供了哪些模板方法？

大概分为三类：独占锁的获取与释放、共享锁的获取与释放、同步状态的查询与设置

### Java的各种锁机制

* 公平锁、非公平锁
  * 公平锁：是指多个线程按照申请锁的顺序来获取锁，类似排队打饭，先到先得。
  * 非公平锁：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁在[高并发](https://so.csdn.net/so/search?q=高并发&spm=1001.2101.3001.7020)的情况下，有可能会造成优先级反转或者饥饿现象。
  * 应用：并发包中ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或非公平锁，默认是非公平锁
* 可重入锁
  * 指的是同一个线程外层函数获得锁之后，内层递归函数仍然能获得该锁的代码，在同一个线程在外层方法获取锁的时候，在进入内层方法会自动回去锁
  * 也即是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块。
  * 应用： ReentrantLock和Synchronize就是典型的可重入锁
* 自旋锁
  * 是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU
* 独占锁（写锁）/共享锁（读锁）/互斥锁
  * 独占锁：指该锁一次只能被一个线程所持有。对ReentrantLock和Synchronized而言都是独占锁
  * 共享锁：指该锁可以被多个线程所持有。
  * 对ReentrantReadWriteLock其读锁是共享锁，写锁是独占锁。

### ReentrantLock

ReentrantLock基于AQS，它实现了公平锁和非公平锁，在开发中可以用它对共享资源进行同步。此外，和synchronized一样，Reentrantlock支持可重入，但ReentrantLock在调度上更灵活，支持更多丰富的功能。

ReentrantLock主要依靠AQS维护一个阻塞队列，多个线程加锁时，失败则会进入阻塞队列。等待唤醒，重新尝试加锁。

![image-20221122085055746](https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211220850849.png)

类图如下：

![img](https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211221504408.png)

#### 支持公平锁和非公平锁

* 公平锁：多个线程申请获取同一资源时，需要按照申请顺序，依次获取资源的使用权。
* 非公平锁：资源释放时，任何线程都有机会获去资源，不用按照顺序。
* 默认是非公平锁，可以在构造方法中指定

#### 公平锁原理

FairSync继承Sync，而Sync继承AbstractQueuedSynchronizer。ReentrantLock调用lock方法，最终会调用sync的tryAcquire函数，获取资源。FairSync的tryAcquire函数，当前线程只有在队列为空或者是队首节点的时候，才能获取资源，否则会被加入到阻塞队列中。下面的hasQueuedPredecessors函数用于判断队列是否为空，或者当前元素是否为队首元素。

#### 非公平锁原理

NoFairSync同样继承Sync，ReentrantLock调用lock方法，最终会调用sync的tryAcquire函数，获取资源。而NoFairSync的tryAcquire函数，会调用父类Sync的方法nofairTryAcquire函数。通过对比可以发现，如果资源释放时，新的线程会尝试CAS操作获取资源，而不管阻塞队列中时候有先于其申请的线程。


#### 可重入性

获取独占资源的线程，可以重复得获取该独占资源，不需要重复请求。

ReentrantLock在申请资源的时候，都会判断当前持有独占资源的线程是不是当前线程，如果是的话，只是简单得将state值加1.记录当前线程的重入次数。

ReentrantLock在释放资源的时候，都会调用`tryRelease`,只有state值为0的时候，才会释放资源。换句话说就是，重入多少次，就必须释放多少次

### ThreadPoolExecutor

#### 线程池的工作流程

* 如果当前运行的线程少于corePoolSize，则创建新的工作线程来执行任务（执行这一步骤需要获取全局锁）。
* 如果当前运行的线程大于或等于corePoolSize，而且BlockingQueue未满，则将任务加入到BlockingQueue中。
* 如果BlockingQueue已满，而且当前运行的线程小于maximumPoolSize，则创建新的工作线程来执行任务（执行这一步骤需要获取全局锁）。
* 如果当前运行的线程大于或等于maximumPoolSize，任务将被拒绝，并调用RejectExecutionHandler.rejectExecution()方法。即调用饱和策略对任务进行处理。

#### 线程池的意义

* 减少开销
  * 可以重复使用线程资源
  * 避免大量创建线程导致资源耗尽
* 便于管理
  * 维护线程ID，线程状态信息

#### 线程池参数：

* corePoolSize：核心线程数
  * 线程池中的核心线程数，默认情况下核心线程一直存活在线程池中，如果将 ThreadPoolExecutor 的 allowCoreThreadTimeOut 属性设为 true，如果线程池一直闲置并超过了 keepAliveTime 所指定的时间，核心线程就会被终止。
* maximumPoolSize: 最大线程数，当线程不够时能够创建的最大线程数
* keepAliveTime
  * 线程池的闲置超时时间，默认情况下对非核心线程生效，如果闲置时间超过这个时间，非核心线程就会被回收。如果 ThreadPoolExecutor 的 allowCoreThreadTimeOut 设为 true 的时候，核心线程如果超过闲置时长也会被回收。

* unit：配合 keepAliveTime 使用，用来标识 keepAliveTime 的时间单位。
* workQueue：线程池中的任务队列，使用 execute() 或 submit() 方法提交的任务都会存储在此队列中。
* ThreadFactory：为线程池提供创建新线程的线程工厂
* rejectedExecutionHandler
  * 线程池任务队列超过最大值之后的拒绝策略，RejectedExecutionHandler 是一个接口，里面只有一个 rejectedExecution 方法，可在此方法内添加任务超出最大值的事件处理。ThreadPoolExecutor 也提供了 4 种默认的拒绝策略：
    * new ThreadPoolExecutor.DiscardPolicy()：丢弃掉该任务，不进行处理
    * new ThreadPoolExecutor.DiscardOldestPolicy()：丢弃队列里最近的一个任务，并执行当前任务
    * new ThreadPoolExecutor.AbortPolicy()：直接抛出 RejectedExecutionException 异常
    * new ThreadPoolExecutor.CallerRunsPolicy()：既不抛弃任务也不抛出异常，直接使用主线程来执行此任务。

#### 线程池执行方法execute() VS submit()

execute() 和 submit() 都是用来执行线程池的，区别在于 submit() 方法可以接收线程池执行的返回值。

#### 线程池关闭

线程池关闭，可以使用 shutdown() 或 shutdownNow() 方法，它们的区别是：

* shutdown()：不会立即终止线程池，而是要等所有任务队列中的任务都执行完后才会终止。执行完 shutdown 方法之后，线程池就不会再接受新任务了。
* shutdownNow()：执行该方法，线程池的状态立刻变成 STOP 状态，并试图停止所有正在执行的线程，不再处理还在池队列中等待的任务，执行此方法会返回未执行的任务。
