---
title: MySQL整理
abbrlink: 53373
date: 2022-11-26 10:25:14
categories: 数据库
tags: MySQL
---

* MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。  
* MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。  
* MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型和大型网站的开发都选择 MySQL 作为网站数据库。

<!-- more -->



### 手撕MySQL的sql语句

#### 查找employes里最晚入职员工的所有信息

```sql
select * from employes where hire_date=(select max(hire_date) from employes from employes);
```

#### 查找employes表中入职员工时间排名倒数第三的员工的所有信息

```sql
select * from employes order by hire_date desc limit 2,1;
```

> desc：倒序，asc为正序。此外还可以使用desc tablename命令查询表的详细信息。
>
> limit有两个参数，第一个参数表示从第几行数据开始查，第二个参数表示查几条数据

#### 查询所有非部门领导的员工emp_no

```sql
select emp_no from employes where emp_no not in (select emp_no from dept_manager)
```

#### 查询所有员工具体的薪水salary情况，对于相同的薪水只显示一次，并按照逆序显示

```
select distinct salary from salaries order by salary desc;
```

#### 查询每个班级的平均分

```
select avg(chinese),avg(english) from grade order by class;
```

#### 从id,course,score中select出学生成绩最好的科目及成绩

```
select name,max(score) from id order by id
```

#### MySQL联合索引a,b,c使用

```
abc 能用到索引
bca 能用到索引
cab 能用到索引
ab 能用到索引
ac 能用到索引
ba 能用到索引
ca 能用到索引
bc 用不到索引
b 用不到索引
c 用不到索引
cb 用不到索引
用到索引的有a,ab,abc,ac 因为优化器会自动调整and前后的顺序，所以ba,cba,bca,ca都会用到索引，其他的都不会用到该索引。ac这一组仅仅是a用到索引。
组合索引 有“最左前缀”原则，遇到范围查询(>、<、between、like)就会停止匹配
```

#### 查询中用到的关键词主要包含六个，并且他们的顺序依次为 select–from–where–group by–having–order by

* select：返回的列或表达式
* from：从中检索数据的表
* where：行级过滤
* group by：行分组说明
* having：组级过滤
* order by：输出排序数组
* limit：要检索的行数

### 非关系型数据库和关系型数据库区别，优势比较？

#### 非关系型数据库的优势

1. 性能

NOSQL 是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过 SQL 层的解析，所以性能非常高。

2. 可扩展性

同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。

#### 关系型数据库的优势

1. 复杂查询

可以用 SQL 语句方便的在一个表以及多个表之间做非常复杂的数据查询。

2. 事务支持

使得对于安全性能很高的数据访问要求得以实现。

### 什么是临时表，临时表什么时候删除？

临时表只在当前连接可见，当关闭连接时，MySQL 会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。

创建临时表的语法与创建表语法类似，不同之处是增加关键字 TEMPORARY，如：

```
CREATE TEMPORARY TABLE tmp_table ( NAME VARCHAR (10) NOT NULL, time date NOT NULL ); select * from tmp_table;
```

临时表手动删除：

```
DROP TEMPORARY TABLE IF EXISTS temp_tb;
```

### 什么是sql注入，怎么防止sql注入

用户提交带有恶意的数据与SQL语句进行字符串方式的拼接，从而影响了SQL语句的语义，最终产生数据泄露的现象。

防止sql，将sql语句参数化。

### MySQL的日志有几种，分别介绍一下？

* 重做日志（redo log)
* 回滚日志（undo log)
* 二进制日志（bin log）
* 错误日志（error log）
* 慢查询日志（show query log）
* 一般查询日志（general log）
* 中继日志（relay log）

#### redo log(innoDB 独有)

**作用：**

确保事务的持久性。redo日志记录事务执行后的状态，用来恢复未写入data file的已成功事务更新的数据。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启[mysql](https://www.2cto.com/database/MySQL/)服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。

**内容：**

物理格式的日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。

**什么时候产生：**

事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。

**什么时候释放：**

当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。

**对应的物理文件：**

默认情况下，对应的物理文件位于[数据库](https://www.2cto.com/database/)的data目录下的ib_logfile1&ib_logfile2

innodb_log_group_home_dir 指定日志文件组所在的路径，默认./ ，表示在数据库的数据目录下。

innodb_log_files_in_group 指定重做日志文件组中文件的数量，默认2

**关于文件的大小和数量，由以下两个参数配置：**

innodb_log_file_size 重做日志文件的大小。

innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认1

**其他：**

很重要一点，redo log是什么时候写盘的？前面说了是在事务开始之后逐步写盘的。

之所以说重做日志是在事务开始之后逐步写入重做日志文件，而不一定是事务提交才写入重做日志缓存，原因就是，重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M(这里设置的16M),Innodb存储引擎先将重做日志写入innodb_log_buffer中。然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘:

* Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。
* 每个事务提交时会将重做日志刷新到重做日志文件。
* 当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件.

由此可以看出，重做日志通过不止一种方式写入到磁盘，尤其是对于第一种方式，Innodb_log_buffer到重做日志文件是Master Thread线程的定时任务。

因此重做日志的写盘，并不一定是随着事务的提交才写入重做日志文件的，而是随着事务的开始，逐步开始的。

另外引用《MySQL技术内幕 Innodb 存储引擎》（page37）上的原话：

即使某个事务还没有提交，Innodb存储引擎仍然每秒会将重做日志缓存刷新到重做日志文件。

这一点是必须要知道的，因为这可以很好地解释再大的事务的提交（commit）的时间也是很短暂的。

#### binlog

mysql-binlog是MySQL数据库的二进制日志，用于记录用户对数据库操作的SQL语句（(除了数据查询语句）信息。

可以使用mysqlbin命令查看二进制日志的内容

**作用：**

* 用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。
* 用于数据库的基于时间点的还原。

**什么时候产生：**

* 事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中。
* 这里与redo log很明显的差异就是redo log并不一定是在事务提交的时候刷新到磁盘，redo log是在事务开始之后就开始逐步写入磁盘。
* 因此对于事务的提交，即便是较大的事务，提交（commit）都是很快的，但是在开启了bin_log的情况下，对于较大事务的提交，可能会变得比较慢一些。这是因为binlog是在事务提交的时候一次性写入的造成的，这些可以通过测试验证。

**什么时候释放：**

binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。

#### undo log

**作用：**

保证数据的原子性，保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读

**内容：**

逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的。

**什么时候产生：**

事务开始之前，将当前是的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性

**什么时候释放：**

当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。

**对应的物理文件：**

MySQL5.6之前，undo表空间位于共享表空间的回滚段中，共享表空间的默认的名称是ibdata，位于数据文件目录中。

MySQL5.6之后，undo表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变undo log文件的个数

如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。

#### show query log

慢日志记录执行时间过长和没有使用索引的查询语句，报错select、update、delete以及insert语句，慢日志只会记录执行成功的语句。

1. 查看慢查询时间：
　　show variables like “long_query_time”;默认10s

#### errorlog

错误日志记录着mysqld启动和停止,以及服务器在运行过程中发生的错误的相关信息。在默认情况下，系统记录错误日志的功能是关闭的，错误信息被输出到标准错误输出。

指定日志路径两种方法:

* 编辑my.cnf 写入 log-error=[path]
* 通过命令参数错误日志 mysqld_safe –user=mysql –log-error=[path] &

#### eneral query log

记录了服务器接收到的每一个查询或是命令，无论这些查询或是命令是否正确甚至是否包含语法错误，general log 都会将其记录下来 ，记录的格式为 {Time ，Id ，Command，Argument }。也正因为mysql服务器需要不断地记录日志，开启General log会产生不小的系统开销。 因此，Mysql默认是把General log关闭的。

查看日志的存放方式：show variables like ‘log_output’;

#### relay log

Relay log，我们翻译成中文，一般叫做中继日志，一般情况下它在MySQL主从同步读写分离集群的从节点才开启。主节点一般不需要这个日志。

master主节点的binlog传到slave从节点后，被写道relay log里，从节点的slave sql线程从relaylog里读取日志然后应用到slave从节点本地。从服务器I/O线程将主服务器的二进制日志读取过来记录到从服务器本地文件，然后SQL线程会读取relay-log日志的内容并应用到从服务器，从而使从服务器和主服务器的数据保持一致。

### 数据库高并发的解决方案

* 在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。
* 增加数据库索引。提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）
* 主从读写分离，让主服务器负责写，从服务器负责读。
* 将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度。
* 使用分布式架构，分散计算压力。

### 存储引擎

#### 作用

利用的不同的数据结构来存储数据，以为为用户提供更新、查询数据的技术实现方法。

#### 分类

| **存储引擎** | **描述**                                                     |
| ------------ | ------------------------------------------------------------ |
| ARCHIVE      | 用于数据存档的引擎，数据被插入后就不能在修改了，且不支持索引。 |
| CSV          | 在存储数据时，会以逗号作为数据项之间的分隔符。               |
| BLACKHOLE    | 会丢弃写操作，该操作会返回空内容。                           |
| FEDERATED    | 将数据存储在远程数据库中，用来访问远程表的存储引擎。         |
| InnoDB       | 具备外键支持功能的事务处理引擎                               |
| MEMORY       | 置于内存的表                                                 |
| MERGE        | 用来管理由多个 MyISAM 表构成的表集合                         |
| MyISAM       | 主要的非事务处理存储引擎                                     |
| NDB          | MySQL 集群专用存储引擎                                       |

InnoDB：MySQL 8.0中的默认存储引擎。 InnoDB是用于MySQL的事务安全（兼容ACID）的存储引擎，具有提交，回滚和崩溃恢复功能以保护用户数据。 InnoDB行级锁定（无需升级为更粗粒度的锁定）和Oracle风格的一致非锁定读取可提高多用户并发性和性能。InnoDB将用户数据存储在聚集索引中，以减少基于主键的常见查询的I / O。为了保持数据完整性， InnoDB还支持FOREIGN KEY引用完整性约束。

MyISAM：这些表占用的空间很小。 表级锁定 限制了读/写工作负载中的性能，因此它通常用于Web和数据仓库配置中的只读或只读工作负载中。

Memory：将所有数据存储在RAM中，以便在需要快速查找非关键数据的环境中进行快速访问。该发动机以前称为HEAP发动机。它的用例正在减少；InnoDB借助其缓冲池内存区域，它提供了一种通用且持久的方式来将大多数或所有数据保留在内存中，并 NDBCLUSTER为大型分布式数据集提供了快速的键值查找。

CSV：其表实际上是带有逗号分隔值的文本文件。CSV表允许您以CSV格式导入或转储数据，以便与读取和写入相同格式的脚本和应用程序交换数据。由于CSV表未建立索引，因此通常InnoDB在正常操作期间将数据保留在表中，并且仅在导入或导出阶段使用CSV表。

Archive：这些紧凑的，未索引的表旨在用于存储和检索大量很少参考的历史，归档或安全审核信息。

Blackhole：Blackhole存储引擎接受但不存储数据，类似于Unix /dev/null设备。查询总是返回一个空集。这些表可用于将DML语句发送到从属服务器的复制配置中，但是主服务器不保留其自己的数据副本。

NDB（也称为 NDBCLUSTER）：此集群数据库引擎特别适合于需要尽可能高的正常运行时间和可用性的应用程序。

Merge：使MySQL DBA或开发人员可以在逻辑上对一系列相同的MyISAM表进行分组并将它们作为一个对象引用。适用于VLDB环境，例如数据仓库。

Federated：提供了链接单独的MySQL服务器以从许多物理服务器创建一个逻辑数据库的能力。非常适合于分布式或数据集市环境。

Example：此引擎作为MySQL源代码中的示例，说明了如何开始编写新的存储引擎。它主要是开发人员感兴趣的。存储引擎是什么都不做的 “ 存根 ”。您可以使用此引擎创建表，但是不能在其中存储数据或从中检索数据。

#### InnoDB

InnoDB是事务型数据库的首选引擎，支持事务安全表(ACID)，支持行锁定和外键，InnoDB是默认的MySQL引擎。

##### InnoDB主要特性有:

* (1) InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事务安全(ACID兼容)存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合。
* (2) InnoDB是为处理巨[大数据](https://cloud.tencent.com/solution/bigdata?from=10680)量的最大性能设计。他的CPU效率可能是任何其他基于磁盘的[关系型数据库](https://cloud.tencent.com/product/cdb-overview?from=10680)引擎锁不能匹敌的。
* (3) InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持他自己的缓冲池。InnoDB将他的表和索引在一个逻辑表空间中，表空间可以包含数个文件(或原始磁盘文件)。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上。
* (4) InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键。
* (5) InnoDB被用在众多需要高性能的大型数据库站点上，InnoDB不创建目录，使用InnoDB时，MySQL将在MySQL数据目录下创建一个名为ibdata1的10MB大小的自动扩展数据文件，以及两个名为ib_logfile0和ib_logfile1的5MB大小的日志文件。
* (6) 可以通过自动增长列，方法是auto_increment。
* (7) 支持事务。默认的事务隔离级别为可重复度，通过MVCC(并发版本控制)来实现的。
* (8) 使用的锁粒度为行级锁，可以支持更高的并发。
* (9) 支持外键约束，外键约束其实降低了表的查询速度，但是增加了表之间的耦合度。
* (10) 配合一些热备工具可以支持在线热备份。
* (11) 在InnoDB中存在着缓冲管理，通过缓冲池，将索引和数据全部缓存起来，加快查询的速度。
* (12) 对于InnoDB类型的表，其数据的物理组织形式是聚簇表。所有的数据按照主键来组织。数据和索引放在一块，都位于B+数的叶子节点上。

##### InnoDB的存储表和索引也有下面两种形式：

* (1) 使用共享表空间存储：所有的表和索引存放在同一个表空间中。
*  (2) 使用多表空间存储：表结构放在frm文件，数据和索引放在IBD文件中。分区表的每个分区对应单独的IBD文件，使用分区表的好处在于提升查询效率。

对于InnoDB来说，最大的特点在于支持事务，但这以损失效率来换取和保障。

#### InnoDB和Myisam的特点与区别

在MySQL5.5之前，MyIsam是MySQL的默认数据库引擎，之后的版本是InnoDB。

特点：

* InnoDB ： InnoDB是mysql的默认引擎，支持事务和外键，支持容灾恢复。适合更新频繁和多并发的表 、行级锁
* MyISAM ： 插入和查询速度比较高，支持大文件，但是不支持事务，适合在web和数据仓库场景下使用 表级锁

区别：

* 事务
  * InnoDB支持，MyISAM不支持
* 行数
  * InnoDB没有保存表的行数，MyISAM保存了表的行数，可以直接读取
* 索引存储
  * InnoDB是聚集索引，MyISAM是非聚集索引
* 外键
  * InnoDB支持，MyISAM不支持
* 锁
  * InnoDB支持行锁，表锁。行锁可以提高多用户并发操作，但InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的
  * MyISAM支持表锁

如何选择：

* 是否要支持事务，如果要请选择 InnoDB，如果不需要可以考虑 MyISAM；

* 如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果既有读写也挺频繁，请使用InnoDB。

* 系统奔溃后，MyISAM恢复起来更困难，能否接受，不能接受就选 InnoDB；

* MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共

  睹的。如果你不知道用什么存储引擎，那就用InnoDB，至少不会差。

### InnoDB 支持的索引类型

* B+树索引
* 全文索引
* 哈希索引：哈希索引是自适应的，InnoDB存储引擎会根据表的使用情况自动为表生成哈希索引，不能认为干预是否在一张表中生成哈希索引。

### B树与二叉树的对比

数据库索引是存储在磁盘上，当表中的数据量比较大时，索引的大小也跟着增长，达到几个G甚至更多。当我们利用索引进行查询的时候，不可能把索引全部加载到内存中，只能逐一加载每个磁盘页，这里的磁盘页就对应索引树的节点。每个结点加载一次磁盘io，减少磁盘IO的次数就必须要压缩树的高度，让瘦高的树尽量变成矮胖的树。

* 平衡二叉树由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。为了减少磁盘ＩＯ的次数，就你必须降低树的深度
* B树这种数据结构常常用于实现数据库索引，查找效率比较高

### MySQL B+Tree 索引和 Hash 索引的区别？

* Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位;
* B+树索引需要从根节点到枝节点，最后才能访问到页节点这样多次的 IO 访问;

B+树索引和哈希索引的明显区别是：

* 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；
* 如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；
* 同理，哈希索引没办法利用索引完成排序，以及 like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；
* 哈希索引也不支持多列联合索引的最左匹配规则；

在大多数场景下，都会有范围查询、排序、分组等查询特征，用 B+树索引就可以了。

#### Hash 索引

* Hash 索引仅仅能满足"=",“IN"和”<=>"查询，不能使用范围查询,因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和 Hash 运算前完全一样；
* Hash 索引无法被用来避免数据的排序操作，因为 Hash 值的大小关系并不一定和 Hash 运算前的键值完全一样；
* Hash 索引不能利用部分索引键查询，对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用；
* Hash 索引在任何时候都不能避免表扫描，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要回表查询数据；
* Hash 索引遇到大量 Hash 值相等的情况后性能并不一定就会比 B+树索引高。

#### B+Tree 索引

常用的 InnoDB 引擎中默认使用的是 B+树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在 InnoDB 中默认开启自适应哈希索引），通过观察搜索模式，MySQL 会利用 index key 的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。

### 为什么用B+树，为什么不用红黑树和B树

B+树是一种特殊的平衡多路树，是B树的优化改进版本，它把所有的数据都存放在叶节点上，中间节点保存的是索引。这样一来相对于B树来说，减少了数据对中间节点的空间占用，使得中间节点可以存放更多的指针，使得树变得更矮，深度更小，从而减少查询的磁盘IO次数，提高查询效率。另一个是由于叶节点之间有指针连接，所以可以进行范围查询，方便区间访问。

而红黑树是二叉的，它的深度相对B+树来说更大，更大的深度意味着查找次数更多，更频繁的磁盘IO，所以红黑树更适合在内存中进行查找。

### B树和B+树的区别

* 关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。
* 存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。
* 分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和子树数据的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。
* 查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。

### B+树相比B树优点

* B+树的分支结点仅仅存储着关键字信息和子树数据的指针，本身的占用空间较小，因此可以容纳更多节点元素，也就是说同样数据情况下，B+ 树会 B 树更加“矮胖”，因此查询效率更快。
* 查找某个范围的数据，只需在B+树的叶子节点链表中遍历即可，不需要像B 树那样挨个中序遍历比较大小。

总结来说，B+树的优点就是：

* 层级更低，IO 次数更少；
* 每次都需要查询到叶子节点；
* 查询性能稳定叶子节点形成有序链表，范围查询方便

B树主要应用于文件系统以及部分数据库索引，如MongoDB，所以目前大部分关系型数据库索引是使用B+树实现。

* B树：有序数组+平衡多叉树
* B+树：有序数组链表+平衡多叉树

Mysql的innodb是以页为存储单位的，每个B+Tree的叶子节点都是一个页的大小的倍数，默认一页的大小是16K

也就是每一个页都包含两个页指针，一个是previous page指针，指向上一个页，一个是next page指针，指向下一个页。
头部还有Page的类型信息和用来唯一标识Page的编号。根据这个指针分布可以想象到Page链接起来就是一个双向链表。

由于一个B+Tree的叶子节点是一个页，所以每个叶子节点之间是一个双向链表的结构。

### B+树一个节点有多大？一千万条数据，B+树多高？

* B+树一个节点的大小设为一页或页的倍数最为合适。因为如果一个节点的大小 < 1页，那么读取这个节点的时候其实读取的还是一页，这样就造成了资源的浪费。
* 在 MySQL 中 B+ 树的一个节点大小为“1页”，也就是16k。之所以设置为一页，是因为对于大部分业务，一页就足够了：
  * 首先InnoDB的B+树中，非叶子节点存的是key + 指针；叶子节点存的是数据行。
  * 对于叶子节点，如果一行数据大小为1k，那么一页就能存16条数据；对于非叶子节点，如果key使用的是bigint，则为8字节，指针在mysql中为6字节，一共是14字节，则16k能存放 16 * 1024 / 14 = 1170 个索引指针。于是可以算出，对于一颗高度为2的B+树，根节点存储索引指针节点，那么它有1170个叶子节点存储数据，每个叶子节点可以存储16条数据，一共 1170 x 16 = 18720 条数据。而对于高度为3的B+树，就可以存放 1170 x 1170 x 16 = 21902400 条数据（两千多万条数据），也就是对于两千多万条的数据，我们只需要高度为3的B+树就可以完成，通过主键查询只需要3次IO操作就能查到对应数据。所以在 InnoDB 中B+树高度一般为3层时，就能满足千万级的数据存储，所以一个节点为1页，也就是16k是比较合理的。

### 为什么要使用自增ID作为主键

#### 什么是自增ID（MySQL数据库）

* 自增ID是在设计表时如果将id字段的值设置为自增的形式也就是AUTO_INCREMENT， 那么当插入一行数据时就无需指定id，数据表会根据前一个id值+1进行填充。
* 指定了AUTO_INCREMENT的列必须要建索引，一般把ID作为主键，这样系统会自动为ID建立索引

#### 自增ID有什么好处？

* 增加记录时，可以不用指定id字段，不用担心主键重复问题
* 数据库自动编号，速度快，而且是增量增长，按顺序存放，对于检索非常有利
* 数字型，占用空间小，易排序，在程序中传递也方便

### 数据库范式

范式之间的关系，第一范式包含第二范式，第二范式包含第三范式。这里只举反例，因为实际的数据在设计数据库表的时候，范式都是相对的。

* 第一范式 1NF：确保每列保持原子性，所有字段值都是不可分解的原子值

* 第二范式 2NF：
  * 需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）；
  * 或者说每一个非主属性都完全函数依赖与任何一个主键

* 第三范式 3NF：数据表中的每一列数据都和主键直接相关，而不能间接相关

### SQL优化

定义执行效率较低的 sql 语句

* 通过慢查询日志定位那些执行效率较低的 sql 语句，用 --log-slow-queries[=file_name] 选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 sql 语句的日志文件。
* 慢查询日志在查询结束以后才记录，所以在应用反映执行效率出现问题的时候慢查询日志并不能定位问题，可以使用 show processlist 命令查看当前 mysql 在进行的线程，包括线程的状态、是否锁表等，可以实时的查看 sql 的执行情况，同时对一些锁表操作进行优化。

通过 explain 分析低效 sql 的执行计划

执行explain 后再执行 show warnings，可以看到sql 真正被执行之前优化器做了哪些 sql 改写（优化的空间也是有限的）

重构查询方式

* 切分大查询
* 分解大连接查询

#### 自主优化：

使用explain分析SQL语句，找到type查询中使用了何种类型

结果值从最好到最坏：system>const>eq_ref>ref>fulltext>ref_or_null>index_merge>unique_subquery>index_subquery>range>index>all

- 一般来说，得保证查询至少达到range级别，最好能到达ref
- system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现
- const：表示通过索引一次就能够找到
- eq_ref:唯一性索引扫描，对于每个索引键，表示只有一条记录与之匹配，常见于主键或唯一索引扫描
- ref：非唯一性索引扫描，返回匹配某个单独值的所有行
- range：只检索给定范围的行，使用一个索引来选择行，一般就是在where语句中出现了between、<、>、in等的查询
- index：index比all快，因为index是从索引中读取，all是从硬盘中读取
- all：遍历全表才能找到

#### 优化建议

* 声明NOT NULL

* 考虑使用数值类型代替字符串

* 考虑使用ENUM类型
* 尽量使用覆盖索引
* 如果使用索引，避免索引失效
  * 使用！=、<>、is null、is not null
  * 使用like以通配符开头
  * 字符串不加单引号
  * 对索引列进行运算.需要建立函数索引
  * 使用or
  * 违背最左匹配原则（复合索引，缺少最左列）

### Mysql的表空间方式，各自特点

共享表空间：指的是数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。

独立表空间：每一个表都将会生成以独立的文件方式来进行存储。

* 优点：当表被删除时这部分空间可以被回收；可以更快的恢复和备份单个表；将单个表复制到另一个实例会很方便；
* 缺点：mysqld会维持很多文件句柄，表太多会影响性能。如果很多表都增长会导致碎片问题。

### MySQL事务

#### 事务的ACID特性

事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。

* 原子性
  * 事务所包含的一系列数据库操作要么全部成功执行，要么全部回滚
  * 事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响
* 一致性：
  * 数据库事务的一致性是指：在事务开始以前，数据库中的数据有一个一致的状态。
  * 在事务完成后，数据库中的事务也应该保持这种一致性。事务应该将数据从一个一致性状态转移到另一个一致性状态。
  * 比如在银行转账操作后两个账户的总额应当不变。
* 隔离性：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。
* 持久性：事务完成后，事务对数据库的所有更新将被保存到数据库，即使系统崩溃，修改的数据页不会丢失。

事务的ACID是通过InnoDB日志和锁来保证。

* 事务的隔离性是通过数据库锁和MVCC的机制实现的
* 持久性通过redo log（重做日志）来实现
* 原子性和一致性通过Undo log（回撤日志）来实现。
  * Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo Log）。然后进行数据的修改。如果出现了错误或者用户执行了roll back语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。
  * 和Undo Log相反，Redo Log记录的是新数据的备份。在事务提交前，只要将RedoLog持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是RedoLog已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。

#### 事务并发问题

在并发的环境下会出现，脏读、不可重复读、幻读，事务隔离级别可以解决这些问题。

并发问题：

* 脏读：并发事务中，一个事务读到了另一个未提交事务修改过的数据
* 不可重复读：一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。
* 幻读：在一个事务两次读取的之间，有新的数据提交。

数据库实现事务隔离的方式，基本上可分为以下两种：

* 一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。
* 另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)，并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度来看，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（MultiVersion Concurrency Control，简称MVCC或MCC）

隔离级别：

* 读未提交：可以读取事务中修改但未提交的数据。会出现：脏读、不可重复读、幻读

* 读已提交：在事务未提交之前，只能查询到旧值。会出现：不可重复的、幻读

* 可重复读：事务B只能在事务A修改过数据并提交后，自己也提交事务后，才能读取到事务B修改的数据。会出现幻读。

  * 为什么上了写锁（写操作），别的事务还可以读操作？

    因为InnoDB有MVCC机制（多版本并发控制），可以使用快照读，而不会被阻塞。

* 串行化：除了读读操作不会阻塞，其他都会阻塞。


MySql使用不同的锁策略(Locking Strategy)/MVCC来实现四种不同的隔离级别。

- 读提交、可重复读的实现原理跟MVCC有关
- 读未提交和串行化跟锁有关。

### 隔离级别的实现原理

使用MySQL的默认隔离级别（可重复读）来进行说明。

每条记录在更新的时候都会同时记录一条回滚操作（回滚操作日志undo log）。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。即通过回滚（rollback操作），可以回到前一个状态的值。

假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。

![彻底搞懂 MySQL 事务的隔离级别](https://cdn.learnku.com/uploads/images/202002/05/32495/mfZfSEBBSn.png!large)

当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。

同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。

提问：回滚操作日志（undo log）什么时候删除？

MySQL会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。

提问：什么时候不需要了？

当系统里么有比这个回滚日志更早的read-view的时候。

### 快照读&当前读

快照读：

读取的是记录数据的可见版本（可能是旧的版本），不加锁,普通的select语句都是快照读

如：简单的select操作，没有lock in share mode或for update，快照读不会加任何的锁，而且由于mysql的一致性非锁定读的机制存在，任何快照读也不会被阻塞。

但是如果事务的隔离级别是SERIALIZABLE的话，那么快照读也会被加上共享的next-key锁

```sql
 select * from account where id>2;
```

当前读：

读取的是记录数据的最新版本，显示加锁的都是当前读

就是insert，update，delete,select…in share mode和select…for update,当前读会在所有扫描到的索引记录上加锁，不管它后面的where条件到底有没有命中对应的行记录。当前读可能会引起死锁。

```sql
select * from account where id>2 lock in share mode;
select * from  account where id>2 for update;
```

### select for update有什么含义，会锁表还是锁行还是其他？

select for update 含义

select查询语句是不会加锁的，但是select for update除了有查询的作用外，还会加锁呢，而且它是悲观锁哦。至于加了是行锁还是表锁，这就要看是不是用了索引/主键啦。

没用索引/主键的话就是表锁，否则就是是行锁。

select for update 获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。

### 多版本并发控制MVCC

MVCC，中文叫多版本并发控制，它是通过读取历史版本的数据，来降低并发事务冲突，从而提高并发性能的一种机制。它的实现依赖于隐式字段、undo日志、快照读&当前读、Read View,

>  多版本并发控制不支持myisam存储引擎。

不同的事务在并发过程中， SELECT 操作可以不加锁而是通过 MVCC 机制读取指定的版本历史记录，并通过一些手段保证保证读取的记录值符合事务所处的隔离级别，从而解决并发场景下的读写冲突。

在Mysql的InnoDB引擎中就是指在提交已读和可重复读两种隔离级别下的事务对于SELECT操作会访问版本链中的记录的过程。

### InnoDB的MVCC实现机制

InnoDB存储引擎，每一行记录都有两个隐藏列DB_TRX_ID、DB_ROLL_PTR

* DB_TRX_ID，记录每一行最近一次修改（修改/更新）它的事务ID，大小为6字节；
* DB_ROLL_PTR，相当于一个指针，指向回滚段的undo日志，大小为7字节

多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，然后通过回滚指针（DB_ROLL_PTR）连一条Undo日志链。

### Read View

Read View就是事务执行快照读时，会生成数据库系统当前的一个快照，记录当前系统中还有哪些活跃的读写事务，把它们放到一个列表里。也就是begin了还未提交的事务,通过这个列表来判断记录的某个版本是否对当前事务可见

* 如果访问的记录版本的事务id比当前列表最小的id小，表明生成该版本的事务在生成ReadView前已经提交(因为事务ID是递增的)，所以该版本可以被当前事务访问。
* 如果访问的记录版本的事务id比当前列表最小的id大，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。
* 如果你要访问的记录版本的事务id在列表id最大值和最小值之间，再判断是否在列表内，如果在就说明此事务还未提交，当前事务也是看不见的。如果不在那说明事务已经提交，当前事务是能看见的

可重复读每次读取数据前都生成一个ReadView，而已提交读在只第一次读取数据时生成一

ReadView。

Mysql的MVCC通过版本链，实现多版本，可并发读-写，写-读。通过ReadView生成策略的不同实现不同的隔离级别。

* 提交已读存在不可重复读问题
* 可重复读解决不可重复读问题

### MySQL中有几种锁

#### 按锁的粒度分为：行锁，表锁、页锁

* 表锁：

  * 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。

  * 特点：

    * 开销小，加锁快
    * 锁定力度大
    * 发生锁冲突概率高，并发度最低
    * 不会出现死锁

  * 使用：

    * 对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个别特殊事务中，也可以考虑使用表级锁：

      * （1）事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。
      * （2）事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。
        当然，应用中这两种事务不能太多，否则，就应该考虑使用MyISAM表了。

    * 在InnoDB下，使用表锁要注意以下两点。

      * （1）使用LOCK TABLES虽然可以给InnoDB加表级锁，但必须说明的是，表锁不是由InnoDB存储引擎层管理的，而是由其上一层──MySQL Server负责的，仅当autocommit=0、InnoDB_table_locks=1（默认设置）时，InnoDB层才能知道MySQL加的表锁，MySQL Server也才能感知InnoDB加的行锁，这种情况下，InnoDB才能自动识别涉及表级锁的死锁，否则，InnoDB将无法自动检测并处理这种死锁。

      * （2）在用 LOCK TABLES对InnoDB表加锁时要注意，要将AUTOCOMMIT设为0，否则MySQL不会给表加锁；事务结束前，不要用UNLOCK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK并不能释放用LOCK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁。

      ```
        SET AUTOCOMMIT=0;
        LOCK TABLES t1 WRITE, t2 READ, ...;
        [do something with tables t1 and t2 here];
        UNLOCK TABLES;
      ```

* 行锁：

  * 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。由字面意思理解，就是给某一行加上锁，也就是一条记录加上锁。
  * 特点：
    * 开销大，加锁慢
    * 会出现死锁
    * 锁定粒度小
    * 发生锁冲突的概率低，并发度高
  * 使用：
    * 行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。

* 页锁：

  * 表级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁.表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。
  * 特点：
    * 开销和加锁速度介于表锁和行锁之间
    * 会出现死锁
    * 锁定力度介于表锁和行锁之间，并发度一般

#### 按锁的操作分为：读写锁（共享锁&排他锁）

* 读锁（共享锁）

  * 读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。

  * 如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。

  ```
  SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
  ```

* 写锁（排他锁）

  * 如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。

  ```
  SELECT * FROM table_name WHERE ... FOR UPDATE
  ```

  * > 在使用读锁、写锁时都需要注意，读锁、写锁属于行级锁。即事务1 对商品A 获取写锁，和事务2 对商品B 获取写锁互相不会阻塞的。需要我们注意的是我们的SQL要合理使用索引，当我们的SQL 全表扫描的时候，行级锁会变成表锁。
    >
    > 使用`EXPLAIN`查看 SQL是否使用了索引，扫描了多少行

#### 按锁的机制分：乐观锁&悲观锁

* 乐观锁
  * 乐观锁假设数据一般情况下不会造成冲突，在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。
  * 可以使用版本号机制和CAS算法实现。**乐观锁适用于多读的应用类型**,**可以提高吞吐量**
    * 版本号机制，是在表中维护一个版本字段，在查询时将版本号和数据一同查询出来，在更新时版本自增1，并判断版本号是否发生变化。
    * CAS算法：java中的compareandswap即cas，解决多线程并行情况下使用锁造成性能损耗的一种机制。
    * CAS操作包含三个操作数，内存位置（V）,预期原值（A）和新值（B）。如果内存位置的值与预期原值相匹配，那么处理器会西东将该位置值更新为新值。否则，处理器不做任何操作。
* 悲观锁
  * 悲观锁假设数据在并发操作一定会发生冲突，所以在数据开始读取的时候就把数据锁住
  * 传统的关系数据库里边就用到了许多这种锁机制，比如行锁，表锁，读锁，写锁，都是在操作之前先上锁
  * 悲观锁分为共享锁和排他锁：
    * 共享锁【Shared lock】又称为读锁，简称S锁。顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。
    * 排他锁【Exclusive lock】又称为写锁，简称X锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据行读取和修改。
  * 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证
  * 悲观锁和乐观锁是数据库用来保证数据并发安全防止更新丢失的两种方法，例子在select … for update前加个事务就可以防止更新丢失。悲观锁和乐观锁大部分场景下差异不大，一些独特场景下有一些差别，一般我们可以从如下几个方面来判断。
    * 响应速度：如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。
    * 冲突频率：如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。
    * 重试代价：如果重试代价大，建议采用悲观锁。
  * 使用场景：
    * 一般情况下，**读多写少更适合用乐观锁，读少写多更适合用悲观锁**。乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能。

### 在Innodb引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候或只锁住一行呢？

- 只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁
- innodb 的行锁是在有索引的情况下,没有索引的表是锁定全表的

### 记录锁（Record lock）

单条索引记录上加锁，record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。

### 间隙锁（Gap Locks）

在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。gap lock的机制主要是解决可重复读模式下的幻读问题(严格意义上，间隙锁并没有完全解决幻读)

* 如果当前索引行是唯一索引，则只会锁定当前索引，不会锁定索引的前后行
* 如果当前索引非唯一索引或不存在数据，则会锁定前后行数据

GAP锁主要针对插入语句，更新语句不会产生GAP

innodb自动使用间隙锁的条件：
（1）必须在可重复读级别下
（2）检索条件必须有索引（没有索引的话，mysql会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加）

### Next-Key Locks

Next-Key Locks是在存储引擎innodb、事务级别在可重复读的情况下使用的数据库锁。

next-key锁其实包含了记录锁和间隙锁，即锁定一个范围，并且锁定记录本身，InnoDB默认加锁方式是next-key 锁

当select for update为索引加上锁（行锁）的同时，索引值所处的区间会被加上Gap锁，而被加上Gap锁的区间无法insert数据

### 什么情况下会造成死锁

所谓死锁: 是指两个或两个以上的进程在执行过程中。

因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。

此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程。

表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的 InnoDB。

死锁的关键在于：两个(或以上)的 Session 加锁的顺序不一致。

那么对应的解决死锁问题的关键就是：让不同的 session加锁有次序。

### 死锁的解决办法

* 查出的线程杀死 kill

```
SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;
```

* 设置锁的超时时间

  Innodb 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）。

* 生产环境不推荐使用过大的 innodb_lock_wait_timeout参数值
  * 该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时间，如下：set innodb_lock_wait_timeout=1000（s）

### varchar 和 char 的使用场景？

char 的长度是不可变的，而 varchar 的长度是可变的。

定义一个 char[10]和 varchar[10]。

如果存进去的是‘csdn’,那么 char 所占的长度依然为 10，除了字符‘csdn’外，后面跟六个空格，varchar 就立马把长度变为 4 了，取数据的时候，char 类型的要用 trim()去掉多余的空格，而 varchar 是不需要的。

char 的存取数度还是要比 varchar 要快得多，因为其长度固定，方便程序的存储与查找。

char 也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率。

varchar 是以空间效率为首位。

char 的存储方式是：对英文字符（ASCII）占用 1 个字节，对一个汉字占用两个字节。

varchar 的存储方式是：对每个英文字符占用 2 个字节，汉字也占用 2 个字节。

两者的存储数据都非 unicode 的字符数据。

### 一条查询语句在 MySQL 中是如何执行的?

MySQL可以分为Server层和存储引擎层两部分

![image-20221201180847847](https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202212011808049.png)

1、应用程序把查询SQL语句发送给服务器端执行

2、查询缓存，如果命中，直接返回

3、查询优化处理，生成执行计划

* 解析SQL
* 预处理
* 优化执行计划

4、MySQL根据相应的执行计划完成整个查询

5、将查询结果返回客户端

### MySQL的意向锁

一种表级锁，用来解决行锁和表锁共存问题的。

当一个事务在需要获取资源的锁定时，如果该资源已经被排他锁占用，则数据库会自动给该事务申请一个该表的意向锁。如果自己需要一个共享锁定，就申请一个**意向共享锁**。如果需要的是某行（或者某些行）的排他锁定，则申请一个**意向排他锁**。

### [MySQL的主从复制](https://zhuanlan.zhihu.com/p/96212530)

#### 1、什么是mysql的主从复制？

MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。

#### 2、mysql复制原理

原理：

（1）master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；

（2）slave服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/OThread请求master二进制事件

（3）同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。

总结：

- 从库会生成两个线程,一个I/O线程,一个SQL线程;
- I/O线程会去请求主库的binlog,并将得到的binlog写到本地的relay-log(中继日志)文件中;
- 主库会生成一个log dump线程,用来给从库I/O线程传binlog;
- SQL线程,会读取relay log文件中的日志,并解析成sql语句逐一执行;
